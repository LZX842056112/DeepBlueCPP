# 第 21 课：C++ IO 流详解

## 课程目标
通过本课程学习，学生将能够：
- 理解 C++ IO 流的基本概念和工作原理
- 熟练使用标准 IO 流对象进行输入输出操作
- 掌握文件 IO 的基本操作和高级功能
- 学会使用字符串流处理内存中的数据
- 能够独立完成涉及 IO 操作的编程任务

## 1. 什么是 IO 流？
在 C++ 中，IO 流（Input/Output Stream）是一种用于处理程序与外部世界（如文件、键盘、屏幕等）之间数据交互的机制。可以将 IO 流想象成一个"流动的管道"，数据从一端"流入"程序，或从程序"流出"到另一端。

**核心思想：** 将输入输出操作抽象为字节序列的流动。

**数据流向示意图：**

```
输入设备 → 输入流 → 程序 → 输出流 → 输出设备
   键盘     →   cin   → 程序 →  cout  →   屏幕
   文件     → ifstream → 程序 → ofstream →   文件
```

**主要优点：**
*   **统一接口：** 无论数据来源是文件、键盘还是网络，都可以使用相同的 IO 流操作。
*   **类型安全：** C++ IO 流具有类型检查，可以避免许多常见的输入输出错误。
*   **可扩展性：** 可以自定义 IO 流，以处理特殊的数据格式或设备。
*   **支持缓冲：** 通过缓冲区减少实际 I/O 操作次数，显著提高读写效率。

## 2. C++ 标准 IO 流对象
C++ 提供了四个预定义的标准 IO 流对象，它们都包含在 `<iostream>` 头文件中：

| 对象   | 描述                                 | 特点与用途                             |
| ------ | ------------------------------------ | -------------------------------------- |
| `cin`  | 标准输入流（通常与键盘关联）         | 缓冲输入，常用于读取用户输入           |
| `cout` | 标准输出流（通常与屏幕关联）         | 缓冲输出，常用于显示程序结果           |
| `cerr` | 标准错误流（无缓冲，通常与屏幕关联） | 无缓冲，错误信息立即显示，适合关键错误 |
| `clog` | 标准日志流（有缓冲，通常与屏幕关联） | 有缓冲，适合记录非关键日志信息         |

**为什么同时需要 cerr 和 clog？**

- `cerr` 无缓冲，确保错误信息立即输出，即使在程序崩溃时也能看到最后的错误信息
- `clog` 有缓冲，适合大量日志输出，性能更好

**示例：**
```cpp
#include <iostream>
int main() {
  int age;
  std::cout << "请输入您的年龄：" ;  // 提示用户输入
  std::cin >> age;                // 从标准输入读取整数
  std::cout << "您的年龄是：" << age << std::endl; // 输出到标准输出
  if (age < 0) {
    std::cerr << "错误：年龄不能为负数！" << std::endl; // 输出错误信息
  } else {
    std::clog << "日志：用户输入了有效年龄 " << age << std::endl; // 记录日志
  }
  return 0;
}
```

## 3. 输入流（Input Stream）
输入流用于从外部设备（如键盘、文件）读取数据。`cin` 是最常用的标准输入流对象。

### 3.1. `cin` 常用方法

*   `operator>>`：从输入流中提取数据，并根据目标变量的类型进行转换。
*   `get()`：
    *   `cin.get()`：读取一个字符（包括空白字符）。
    *   `cin.get(char& ch)`：读取一个字符到 `ch`。
    *   `cin.get(char* str, streamsize n)`：读取最多 `n-1` 个字符到 `str`，遇到换行符或文件结束符停止。
    *   `cin.get(char* str, streamsize n, char delim)`：读取最多 `n-1` 个字符到 `str`，遇到 `delim` 或换行符或文件结束符停止
*   `getline()`：
    *   `cin.getline(char* str, streamsize n)`：读取一行文本（最多 `n-1` 个字符），遇到换行符或文件结束符停止。
    *   `cin.getline(char* str, streamsize n, char delim)`：读取一行文本（最多 `n-1` 个字符），遇到 `delim` 或换行符或文件结束符停止。
*   `ignore()`：
    *   `cin.ignore()`：忽略输入流中的一个字符。
    *   `cin.ignore(streamsize n)`：忽略输入流中的 `n` 个字符
    *   `cin.ignore(streamsize n, int delim)`：忽略 `n` 个字符，或者在遇到定界符 `delim` 时停止
*   `peek()`：查看输入流中的下一个字符，但不将其从流中移除。
*   `gcount()`：返回上一次非格式化输入操作读取的字符数。

**输入缓冲区问题：**
当混合使用 `operator>>` 和 `getline()` 时，常会遇到缓冲区问题。`operator>>` 读取后会在缓冲区留下换行符，影响后续的 `getline()` 操作。解决方法是在 `getline()` 前使用 `ignore()` 清除缓冲区。

**示例：**
```cpp
#include <iostream>
#include <string>
int main() {
  char ch;
  std::cout << "请输入一个字符：";
  std::cin.get(ch);  // 读取一个字符（包括空格）
  std::cout << "您输入的字符是：" << ch << std::endl;
  
  char buffer[80];
  std::cout << "请输入一行文本：";
  std::cin.ignore(); // 清除缓冲区中的换行符
  std::cin.getline(buffer, 80);  // 读取一行文本
  std::cout << "您输入的文本是：" << buffer << std::endl;
  
  // 使用 string 和 getline() 读取一行
  std::string line;
  std::cout << "请输入另一行文本 (string): ";
  std::getline(std::cin, line); // string版本的getline不需要ignore()
  std::cout << "您输入的文本是: " << line << std::endl;
    
  return 0;
}
```

### 3.2 输入流的状态
输入流对象（如 `cin`）具有内部状态标志，用于指示流的状态。可以使用以下成员函数检查这些状态：

| 状态函数 | 描述                                                         | 处理方法                   |
| -------- | ------------------------------------------------------------ | -------------------------- |
| `good()` | 如果流处于正常状态（没有错误发生），返回 `true`              | 继续使用                   |
| `eof()`  | 如果到达文件末尾（End-of-File），返回 `true`                 | 结束输入操作               |
| `fail()` | 如果发生可恢复的错误（例如，试图读取一个整数，但输入了非数字字符），返回 `true` | 清除错误状态，忽略错误输入 |
| `bad()`  | 如果发生不可恢复的错误（例如，硬件故障），返回 `true`        | 通常需要终止程序           |

在处理输入时，检查流状态非常重要，以确保输入操作成功完成，并处理可能出现的错误。

```cpp
#include <iostream>
#include <limits> // 用于 numeric_limits
int main() {
    int num;
    std::cout << "请输入一个整数: ";
    while (!(std::cin >> num)) {
        // 输入失败，检查原因
        if (std::cin.eof()) {
            std::cerr << "已到达输入末尾！" << std::endl;
            break; // 退出循环
        } else if (std::cin.fail()) {
            std::cerr << "输入错误，请重新输入一个整数: ";
            std::cin.clear(); // 清除错误状态
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 忽略无效输入
        } else if (std::cin.bad()) {
            std::cerr << "发生严重错误，无法继续！" << std::endl;
            return 1; // 退出程序
        }
    }
    if (std::cin.good()) {
        std::cout << "您输入的整数是: " << num << std::endl;
    }
    return 0;
}
```

## 4. 输出流（Output Stream）
输出流用于向外部设备（如屏幕、文件）写入数据。`cout` 是最常用的标准输出流对象。

### 4.1. `cout` 常用方法
*   `operator<<`：将数据插入到输出流中。
*   `put()`：输出一个字符。
*   `write()`：输出指定数量的字符。

**示例：**

```cpp
#include <iostream>
int main() {
  char ch = 'A';
  std::cout.put(ch);  // 输出字符 'A'
  std::cout << std::endl;
  const char* str = "Hello, world!";
  std::cout.write(str, 5);  // 输出字符串的前 5 个字符 "Hello"
  std::cout << std::endl;
  return 0;
}
```

### 4.2. 格式化输出
C++ 提供了多种方式来控制输出的格式，包括：

**使用操纵符（Manipulators）：** 包含在 `<iomanip>` 头文件中。

| 操纵符                 | 描述                                 | 示例                                    |
| ---------------------- | ------------------------------------ | --------------------------------------- |
| `std::setw(n)`         | 设置字段宽度为 `n`                   | `cout << setw(10) << 42;`               |
| `std::setprecision(n)` | 设置浮点数精度为 `n` 位小数          | `cout << setprecision(4) << 3.14159;`   |
| `std::fixed`           | 以固定点表示法显示浮点数             | `cout << fixed << 3.14159;`             |
| `std::scientific`      | 以科学计数法表示浮点数               | `cout << scientific << 30000000;`       |
| `std::left`            | 左对齐                               | `cout << left << setw(10) << "left";`   |
| `std::right`           | 右对齐（默认）                       | `cout << right << setw(10) << "right";` |
| `std::internal`        | 将填充字符插入到符号和数字之间       | `cout << internal << setw(10) << -100;` |
| `std::hex`             | 以十六进制显示整数                   | `cout << hex << 255;`                   |
| `std::oct`             | 以八进制显示整数                     | `cout << oct << 255;`                   |
| `std::dec`             | 以十进制显示整数（默认）             | `cout << dec << 255;`                   |
| `std::boolalpha`       | 将 `bool` 值显示为 `true` 或 `false` | `cout << boolalpha << true;`            |
| `std::noboolalpha`     | 将 `bool` 值显示为 1 或 0            | `cout << noboolalpha << true;`          |

**实际应用示例：格式化输出表格**

```cpp
#include <iostream>
#include <iomanip>
#include <string>
int main() {
  // 格式化输出学生成绩表格
  std::cout << std::left << std::setw(15) << "姓名" 
            << std::setw(8) << "语文" 
            << std::setw(8) << "数学" 
            << std::setw(8) << "英语" 
            << std::setw(10) << "平均分" << std::endl;
  
  std::cout << std::string(49, '-') << std::endl;
  
  std::cout << std::left << std::setw(15) << "张三" 
            << std::setw(8) << 85 
            << std::setw(8) << 92 
            << std::setw(8) << 78 
            << std::fixed << std::setprecision(2) << std::setw(10) << (85+92+78)/3.0 << std::endl;
  
  std::cout << std::left << std::setw(15) << "李四" 
            << std::setw(8) << 76 
            << std::setw(8) << 88 
            << std::setw(8) << 90 
            << std::fixed << std::setprecision(2) << std::setw(10) << (76+88+90)/3.0 << std::endl;
  
  return 0;
}
```

## 5. 文件 IO

除了标准输入输出流，C++ 还提供了文件流，用于读写文件。

### 5.1. 文件流类
*   `ifstream`：输入文件流，用于从文件读取数据。
*   `ofstream`：输出文件流，用于向文件写入数据。
*   `fstream`：文件流，既可以读取也可以写入数据。

这些类都包含在 `<fstream>` 头文件中。

### 5.2. 文件操作步骤

1.  **打开文件：** 使用 `open()` 方法打开文件，指定文件名和打开模式。
2.  **读/写文件：** 使用 `operator>>`、`operator<<`、`get()`、`getline()`、`read()`、`write()` 等方法进行读写操作。
3.  **关闭文件：** 使用 `close()` 方法关闭文件。

**文件路径注意事项：**

- 在 Windows 中，路径分隔符是 `\`，但在 C++ 字符串中需要写成 `\\`，或者使用 `/`。
- 推荐使用原始字符串字面量（R"()"）来表示文件路径，避免转义问题。
- 相对路径是相对于程序运行时的当前工作目录，而不是程序文件所在目录。

**打开模式：**

| 模式          | 描述                                                     | 适用场景                       |
| ------------- | -------------------------------------------------------- | ------------------------------ |
| `ios::in`     | 以读取模式打开文件（默认）                               | 读取现有文件                   |
| `ios::out`    | 以写入模式打开文件（默认），如果文件存在，则清空文件内容 | 创建新文件或覆盖现有文件       |
| `ios::app`    | 以追加模式打开文件，在文件末尾添加内容                   | 日志文件，不希望覆盖已有内容   |
| `ios::ate`    | 打开文件后，将文件指针定位到文件末尾                     | 需要在文件末尾开始读写的情况   |
| `ios::trunc`  | 如果文件存在，则清空文件内容                             | 确保文件是空的，然后写入       |
| `ios::binary` | 以二进制模式打开文件                                     | 处理非文本文件，如图片、音频等 |

可以使用 `|` 来组合多种模式，例如 `ios::in | ios::binary` 表示以二进制读取模式打开文件。

**示例：读取文件**

```cpp
#include <iostream>
#include <fstream>
#include <string>
int main() {
  // 使用原始字符串字面量表示文件路径
  std::ifstream inputFile(R"(C:\data\example.txt)"); // 打开文件
  if (inputFile.is_open()) {  // 检查文件是否成功打开
    std::string line;
    while (std::getline(inputFile, line)) {  // 逐行读取
      std::cout << line << std::endl;        // 输出每一行
    }
    inputFile.close();  // 关闭文件
  } else {
    std::cerr << "无法打开文件！" << std::endl;
  }
  return 0;
}
```

**示例：写入文件**
```cpp
#include <iostream>
#include <fstream>
int main() {
  std::ofstream outputFile("output.txt");  // 以写入模式打开文件
  //等效于 std::ofstream outputFile("output.txt", std::ios::out);
    
  if (outputFile.is_open()) {
    outputFile << "Hello, file!" << std::endl;
    outputFile << "This is a new line." << std::endl;
    outputFile.close();
  } else {
    std::cerr << "无法创建文件！" << std::endl;
  }
  
  // 以二进制模式写入文件
  std::ofstream binaryFile("data.bin", std::ios::binary);
  if(binaryFile.is_open()){
    int data[] = {1,2,3,4,5};
    // 使用 reinterpret_cast 将整数数组转换为字符指针
    binaryFile.write(reinterpret_cast<char*>(data), sizeof(data));
    binaryFile.close();
  } else {
    std::cerr << "无法创建二进制文件！" << std::endl;
  }
  return 0;
}
```

### 5.3 文件的随机访问
`seekg()` 和 `seekp()` 允许随机访问文件中的数据。`seekg()` 用于输入流 (如 `ifstream`)，而 `seekp()` 用于输出流 (如 `ofstream`)。

- `seekg(offset, origin)` 和 `seekp(offset, origin)`
  - `offset`: 相对于 `origin` 的偏移量（可以是正数或负数）。
  - `origin`: 参考点，可以是以下值之一：
    - `ios::beg`: 文件开头。
    - `ios::cur`: 当前位置。
    - `ios::end`: 文件结尾。
- `tellg()` 和 `tellp()`:
  - 这两个函数用于获取当前文件指针位置，`tellg()` 用于输入流，`tellp()` 用于输出流。

**实际应用示例：修改文件中的特定数据**

```cpp
#include <iostream>
#include <fstream>
#include <string>
int main() {
    // 创建一个简单的数据库文件
    std::ofstream dbFile("database.txt");
    dbFile << "001 张三 25 北京\n";
    dbFile << "002 李四 30 上海\n";
    dbFile << "003 王五 28 广州\n";
    dbFile.close();
    
    // 修改李四的年龄为31
    std::fstream file("database.txt", std::ios::in | std::ios::out);
    if (!file.is_open()) {
        std::cerr << "无法打开数据库文件！" << std::endl;
        return 1;
    }
    
    std::string line;
    while (std::getline(file, line)) {
        if (line.find("002 李四") != std::string::npos) {
            // 找到李四的记录，计算当前位置
            std::streampos pos = file.tellg();
            // 回到行首
            file.seekp(pos - line.length() - 1);
            // 写入修改后的记录
            file << "002 李四 31 上海\n";
            break;
        }
    }
    
    file.close();
    
    // 显示修改后的文件内容
    std::ifstream displayFile("database.txt");
    std::cout << "修改后的数据库内容：" << std::endl;
    while (std::getline(displayFile, line)) {
        std::cout << line << std::endl;
    }
    displayFile.close();
    
    return 0;
}
```

## 6. 字符串流（String Stream）

字符串流提供了一种在内存中操作字符串的 IO 流方式。它允许你像处理文件或标准输入输出一样处理字符串。

### 6.1. 字符串流类
*   `istringstream`：输入字符串流，用于从字符串读取数据。
*   `ostringstream`：输出字符串流，用于向字符串写入数据。
*   `stringstream`：字符串流，既可以读取也可以写入数据。

这些类都包含在 `<sstream>` 头文件中。

### 6.2. 字符串流用法
主要操作：
- `str()`：
  - 无参数：返回字符串流中当前包含的字符串的副本。
  - 有参数（`const std::string& s`）：用字符串 `s` 的内容替换字符串流的当前内容。
- `operator<<`（插入运算符）：将各种类型的数据插入到字符串流中。这些数据会被转换为字符串形式。
- `operator>>`（提取运算符）：从字符串流中提取数据，并将其转换为适当的类型。
- `clear()`: 清除字符串流的错误状态。
- `rdbuf()`: 用于访问或操作与流关联的底层缓冲区。

**实际应用示例：解析复杂格式的数据**

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <iomanip>

struct Person {
    std::string name;
    int age;
    std::string city;
};

// 解析CSV格式的字符串
std::vector<Person> parseCSV(const std::string& csvData) {
    std::vector<Person> people;
    std::istringstream ss(csvData);
    std::string line;
    
    // 跳过标题行
    std::getline(ss, line);
    
    while (std::getline(ss, line)) {
        std::istringstream lineStream(line);
        std::string field;
        std::vector<std::string> fields;
        
        // 分割每行的字段
        while (std::getline(lineStream, field, ',')) {
            fields.push_back(field);
        }
        
        if (fields.size() >= 3) {
            Person p;
            p.name = fields[0];
            p.age = std::stoi(fields[1]);
            p.city = fields[2];
            people.push_back(p);
        }
    }
    
    return people;
}

// 将人员数据转换为HTML表格
std::string toHTMLTable(const std::vector<Person>& people) {
    std::ostringstream html;
    html << "<table border='1'>\n";
    html << "<tr><th>姓名</th><th>年龄</th><th>城市</th></tr>\n";
    
    for (const auto& p : people) {
        html << "<tr><td>" << p.name 
             << "</td><td>" << p.age 
             << "</td><td>" << p.city 
             << "</td></tr>\n";
    }
    
    html << "</table>";
    return html.str();
}

int main() {
    // 模拟CSV格式的数据
    std::string csvData = "姓名,年龄,城市\n"
                         "张三,25,北京\n"
                         "李四,30,上海\n"
                         "王五,28,广州\n";
    
    // 解析CSV数据
    std::vector<Person> people = parseCSV(csvData);
    
    // 转换为HTML表格
    std::string htmlTable = toHTMLTable(people);
    
    // 输出结果
    std::cout << "生成的HTML表格：" << std::endl;
    std::cout << htmlTable << std::endl;
    
    return 0;
}
```

## 7、作业
**题目：**
1. 读取文件中的数据（学生的成绩），根据姓名构造 `Student` 类。
2. 计算均分，并换算成 A-E 等级后，再写入另一个文件。
   * 等级划分：A[90,100] B[80,90) C[70,80) D[60,70) E[0,60)

**提示：**
* 可以使用 `fstream` 读取和写入文件。
* 可以使用 `stringstream` 辅助字符串解析和数据类型转换。
* 注意处理文件打开失败的情况。
* 考虑使用异常处理来增加程序的健壮性。

**参考代码：**
```cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <stdexcept> // 用于异常处理
using namespace std;

class Student {
public:
    string name;
    int chinese;
    int math;
    int english;
    char grade;
    
    Student(string name, int chinese, int math, int english) :
        name(name), chinese(chinese), math(math), english(english) {
        calculateGrade();
    }
    
    void calculateGrade() {
        double average = (chinese + math + english) / 3.0;
        if (average >= 90) {
            grade = 'A';
        } else if (average >= 80) {
            grade = 'B';
        } else if (average >= 70) {
            grade = 'C';
        } else if (average >= 60) {
            grade = 'D';
        } else {
            grade = 'E';
        }
    }
    
    // 添加一个方法，格式化输出学生信息
    string toString() const {
        ostringstream oss;
        oss << name << " " << chinese << " " << math << " " 
            << english << " " << grade << " (" 
            << fixed << setprecision(1) << (chinese + math + english) / 3.0 << ")";
        return oss.str();
    }
};

int main() {
    try {
        // 读取学生成绩数据
        ifstream inputFile("student_scores.txt");
        if (!inputFile.is_open()) {
            throw runtime_error("无法打开输入文件 student_scores.txt");
        }
        
        vector<Student> students;
        string line;
        while (getline(inputFile, line)) {
            // 跳过空行
            if (line.empty()) continue;
            
            stringstream ss(line);
            string name;
            int chinese, math, english;
            
            // 检查是否能成功读取所有数据
            if (!(ss >> name >> chinese >> math >> english)) {
                cerr << "警告：跳过格式错误的行: " << line << endl;
                continue;
            }
            
            // 检查成绩是否在合理范围内
            if (chinese < 0 || chinese > 100 || 
                math < 0 || math > 100 || 
                english < 0 || english > 100) {
                cerr << "警告：跳过成绩超出范围的行: " << line << endl;
                continue;
            }
            
            students.push_back(Student(name, chinese, math, english));
        }
        inputFile.close();
        
        if (students.empty()) {
            throw runtime_error("没有有效的学生数据");
        }
        
        // 写入学生成绩和等级
        ofstream outputFile("student_grades.txt");
        if (!outputFile.is_open()) {
            throw runtime_error("无法创建输出文件 student_grades.txt");
        }
        
        // 写入表头
        outputFile << "姓名 语文 数学 英语 等级 平均分" << endl;
        outputFile << "------------------------" << endl;
        
        for (const Student& student : students) {
            outputFile << student.toString() << endl;
        }
        outputFile.close();
        
        // 同时输出到控制台
        cout << "处理完成，共处理 " << students.size() << " 名学生的数据。" << endl;
        cout << "结果已写入 student_grades.txt" << endl;
        cout << endl << "预览结果：" << endl;
        cout << "姓名 语文 数学 英语 等级 平均分" << endl;
        cout << "------------------------" << endl;
        for (const Student& student : students) {
            cout << student.toString() << endl;
        }
        
    } catch (const exception& e) {
        cerr << "错误: " << e.what() << endl;
        return 1;
    }
    
    return 0;
}
```

**作业要求：**
1. 创建一个文本文件 `student_scores.txt`，输入学生成绩数据，格式为：`姓名 语文 数学 英语`，每行一个学生。
   ```
   张三 85 92 78
   李四 76 88 90
   王五 92 95 89
   赵六 65 72 68
   钱七 55 62 48
   ```

2. 运行程序后，将生成 `student_grades.txt` 文件，包含学生的成绩、等级和平均分。

**扩展任务（选做）：**
1. 添加统计功能，计算各科的平均分、最高分和最低分。
2. 将结果以HTML表格格式输出，便于在浏览器中查看。
3. 添加按等级分类统计功能，统计各等级学生人数和百分比。

## 8. 总结
本次课程我们详细讲解了 C++ IO 流的各个方面，包括：
*   IO 流的基本概念和标准 IO 流对象 (`cin`, `cout`, `cerr`, `clog`)。
*   输入流 (`cin`) 和输出流 (`cout`) 的常用方法和格式化输出。
*   文件 IO (`ifstream`, `ofstream`, `fstream`) 的操作步骤和打开模式。
*   文件的随机访问。
*   字符串流 (`istringstream`, `ostringstream`, `stringstream`) 的用法。

**学习建议：**
1. **实践为主**：IO 流操作是实践性很强的内容，建议多写代码，尝试不同的输入输出场景。
2. **注意错误处理**：文件操作和输入操作都可能失败，养成良好的错误处理习惯。
3. **理解缓冲区**：理解缓冲区的工作原理，有助于解决许多常见的输入输出问题。
4. **探索更多功能**：C++ IO 流还有很多高级功能，如自定义操纵符、国际化支持等，有兴趣的同学可以进一步探索。

**后续学习方向：**
1. 学习 C++ 的文件系统库 (`<filesystem>`)，用于处理文件和目录操作。
2. 了解 C++ 的正则表达式库 (`<regex>`)，结合字符串流进行复杂的文本处理。
3. 探索第三方库，如 Boost.Iostreams，提供更多类型的流和过滤器。

掌握 IO 流是 C++ 编程的基础，希望大家通过本次课程的学习，能够熟练运用 IO 流处理各种输入输出任务。

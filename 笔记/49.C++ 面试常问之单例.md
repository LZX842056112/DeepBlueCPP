# C++ 面试常问之单例
目录
1. 为什么需要单例
2. 单例模式定义与适用场景
3. C++ 实现（推荐与不推荐的多种写法）
4. 线程安全与内存模型要点
5. 生命周期与静态初始化顺序问题
6. 可测试性与替代方案
7. Python 对照实现
8. 练习与讨论

—  
1. 为什么需要单例
- 目标：全局唯一、延迟/受控创建、集中访问
- 典型场景：
  - 日志系统（全局同一落盘/格式）
  - 配置中心（统一加载/缓存）
  - 资源管理（连接池、线程池、字符串池等等）
  - 模型对象
- 风险：变相“全局变量”，隐藏依赖，影响可测试性与可维护性

2. 定义与使用边界
- 定义：某个类在进程内只允许有一个实例，并提供全局访问点
- 使用边界：
  - 适合：确实需要全局唯一状态或昂贵资源
  - 谨慎：并发、插件/动态库边界、多进程
  - 避免：可以通过依赖注入（DI）或参数传递解决的情况

—  

3. C++ 单例实现

3.1 推荐：Meyers Singleton（C++11+，懒加载、线程安全）

- 优点：极简、线程安全（C++11 起保证）、无锁一次构造
- 注意：拷贝/移动需禁用；析构顺序可能影响静态收尾阶段调用

```cpp
// logger_meyers.cpp
#include <iostream>
#include <mutex>
#include <string>

class Logger {
public:
    static Logger& instance() {
        static Logger inst; // C++11 起线程安全
        return inst;
    }

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    Logger(Logger&&) = delete;
    Logger& operator=(Logger&&) = delete;

    void log(const std::string& msg) {
        std::lock_guard<std::mutex> lk(mu_);
        std::cout << msg << std::endl;
    }

private:
    Logger() = default;
    ~Logger() = default;

    std::mutex mu_;
};

int main() {
    auto& L = Logger::instance();
    auto& M = Logger::instance();
    std::cout << &L << std::endl;
    std::cout << &M << std::endl;
    L.log("Hello, Singleton!");
}
```

3.2 推荐：std::call_once + unique_ptr（可控销毁）

- 优点：可显式控制销毁时机；便于解决“静态析构次序不确定”
- 适用：对析构顺序敏感的资源（如先后关闭顺序）

```cpp
// config_once.cpp
#include <mutex>
#include <memory>
#include <unordered_map>
#include <string>

class Config {
public:
    static Config& instance() {
        std::call_once(init_flag_, [] { inst_.reset(new Config()); });
        return *inst_;
    }

    static void destroy() { // 手动销毁（例如在 main 尾部指定时机）
        inst_.reset();
    }

    void set(std::string key, std::string value) {
        std::lock_guard<std::mutex> lk(mu_);
        kv_[std::move(key)] = std::move(value);
    }

    std::string get(const std::string& key) {
        std::lock_guard<std::mutex> lk(mu_);
        auto it = kv_.find(key);
        return it != kv_.end() ? it->second : "";
    }

    Config(const Config&) = delete;
    Config& operator=(const Config&) = delete;
    Config(Config&&) = delete;
    Config& operator=(Config&&) = delete;

private:
    Config() = default;
    ~Config() = default;

    static std::once_flag init_flag_;
    static std::unique_ptr<Config> inst_;

    std::mutex mu_;
    std::unordered_map<std::string, std::string> kv_;
};

std::once_flag Config::init_flag_;
std::unique_ptr<Config> Config::inst_;

#include <iostream>

int main() {
    auto& C = Config::instance();
    C.set("host", "127.0.0.1");
    std::cout << C.get("host") << std::endl;
    Config::destroy(); // 明确收尾
}
```

3.3 可讲解但不推荐：双重检查锁（DCLP）

- 在 C++11 前不安全；C++11 可用 std::atomic + 合适的内存序，但复杂、易错
- 实战优先选 Meyers 或 call_once

```cpp
// dclp_demo.cpp
#include <atomic>
#include <mutex>

class S {
public:
    static S* instance() {
        S* p = ptr_.load(std::memory_order_acquire);
        if (!p) {
            std::lock_guard<std::mutex> lk(m_);
            p = ptr_.load(std::memory_order_relaxed);
            if (!p) {
                p = new S();
                ptr_.store(p, std::memory_order_release);
            }
        }
        return p;
    }

    S(const S&) = delete;
    S& operator=(const S&) = delete;

private:
    S() = default;
    ~S() = default; // 通常不回收，可能有“有意泄漏”以避免析构次序问题

    static std::atomic<S*> ptr_;
    static std::mutex m_;
};

std::atomic<S*> S::ptr_{nullptr};
std::mutex S::m_;
```

3.4 “饿汉式”静态成员
- 提前初始化：简单，但跨翻译单元的“静态初始化顺序问题”更突出
- 一般不推荐给新项目

—  
4. 线程安全与内存模型要点（C++11+）
- 函数内静态对象（Meyers）构造时有一次性线程安全保障
- std::call_once 保证初始化逻辑只执行一次
- DCLP 需使用 std::atomic 指针，记住 acquire/release
- 禁止复制/移动，防止意外多实例
- 动态库/插件边界：如果单例定义在 header 的内联函数中，可能每个 DSO 都有一份；建议把实例放进一个确定的静态库/动态库并导出访问函数

—  
5. 生命周期与静态初始化顺序
- 构造：跨翻译单元的静态对象构造顺序不确定（称为 SIOF）
- Meyers 懒加载可绕开“构造期”SIOF，但销毁期顺序仍不确定
- 解决建议：
  - 不依赖析构（“有意泄漏”——在进程结束时 OS 回收）
  - 用 call_once + unique_ptr + 显式 destroy 控制顺序
  - 在 main 早期手动“预热”实例，尽量减少晚期构造/析构风险

7. Python 对照实现

7.1 模块即单例（最简单、最 Pythonic）

- Python 模块只加载一次，模块变量天然唯一
```python
# logger_module.py
import threading

_mu = threading.Lock()

def log(msg: str) -> None:
    with _mu:
        print(msg)

# 使用：
# import logger_module as logmod
# logmod.log("Hello")
```

7.2 基于 __new__ 的单例（类级）

```python
# logger_new.py
import threading

class Logger:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._init_once()
        return cls._instance

    def _init_once(self):
        self._mu = threading.Lock()

    def log(self, msg: str) -> None:
        with self._mu:
            print(msg)

if __name__ == "__main__":
    a = Logger()
    b = Logger()
    print(a is b)  # True
    a.log("hello")
```
- 说明：避免在 __init__ 里做一次性初始化（因为 __init__ 每次都会被调用）

7.3 基于元类的单例（更优雅、__init__ 只执行一次）

```python
# singleton_meta.py
import threading

class SingletonMeta(type):
    _instances = {}
    _lock = threading.Lock()

    def __call__(cls, *args, **kwargs):
        with cls._lock:
            if cls not in cls._instances:
                cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Logger(metaclass=SingletonMeta):
    def __init__(self):
        self._mu = threading.Lock()

    def log(self, msg: str) -> None:
        with self._mu:
            print(msg)

if __name__ == "__main__":
    a = Logger()
    b = Logger()
    print(a is b)  # True
```

7.4 共享状态（Borg 模式，非严格单例）
```python
# borg.py
import threading

class Borg:
    _shared_state = {}
    def __init__(self):
        self.__dict__ = self._shared_state

class Logger(Borg):
    def __init__(self):
        super().__init__()
        if not hasattr(self, "_mu"):
            self._mu = threading.Lock()

    def log(self, msg: str) -> None:
        with self._mu:
            print(msg)

if __name__ == "__main__":
    a = Logger()
    b = Logger()
    print(a is b)      # False（不是同一对象）
    a.log("shared ok") # 但共享同一状态
```

对照要点（C++ vs Python）
- 生命周期：C++ 需关心静态构造/析构顺序；Python 多数由解释器与 GC 托管
- 线程安全：C++ 需要显式同步；Python 有 GIL 但仍需锁以避免“重复初始化” （Python 3.14已经删除GIL）
- 进程边界：两端都不是跨进程的单例；跨进程需 IPC/文件锁/服务化等


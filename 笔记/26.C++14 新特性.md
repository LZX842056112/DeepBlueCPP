# C++14 新特性

## 目录
1.  **函数返回类型推导**
2.  **泛型 Lambda 表达式 (Generic Lambdas)**
3.  **Lambda 捕获表达式 (Lambda Capture Expressions)**
4.  **变量模板 (Variable Templates)**
5.  **`[[deprecated]]` 属性**
6.  **二进制字面量和数字分隔符**
7.  **`std::make_unique`**
8.  **编译期整数序列 (`std::integer_sequence`)**
9. **总结**
10. **作业**

---

## 1. 函数返回类型推导

### 1.1 简介
C++11 引入了 `auto` 关键字用于自动推导变量类型，C++14 则更进一步，允许函数返回类型也可以自动推导。这一特性极大地简化了函数定义，特别是对于返回复杂类型或模板类型的函数。

### 1.2 从 C++11 到 C++14 的演变

**C++11:**
```cpp
// C++11 需要显式指定返回类型或使用尾随返回类型
auto add(int a, int b) -> decltype(a + b) {
    return a + b;
}

// 对于模板函数，情况更复杂
template<typename T, typename U>
auto multiply(T t, U u) -> decltype(t * u) {
    return t * u;
}
```

**C++14:**
```cpp
// C++14 可以直接使用 auto 推导返回类型
auto add(int a, int b) {
    return a + b;
}

// 模板函数也大大简化
template<typename T, typename U>
auto multiply(T t, U u) {
    return t * u;
}
```

### 1.3 详细示例与应用

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <type_traits>

// 简单数值计算
auto multiply(double x, int y) {
    return x * y;  // 返回类型推导为 double
}

// 返回复杂类型
auto getVector() {
    return std::vector<int>{1, 2, 3, 4, 5};  // 返回类型推导为 std::vector<int>
}

// 递归函数 - 需要至少一个非递归返回语句来启动推导
auto factorial(int n) {
    if (n <= 1) {
        return 1;  // 启动推导，返回类型为 int
    }
    return n * factorial(n - 1);  // 递归调用，返回类型必须与启动推导的类型一致
}

// 模板函数与返回类型推导
template<typename Container>
auto getFirstElement(const Container& container) {
    return *container.begin();  // 返回类型推导为容器的值类型
}

// 与 decltype 结合使用
template<typename T, typename U>
auto divide(T t, U u) -> decltype(t / u) {
    return t / u;
}

int main() {
    auto result = multiply(3.14, 2);
    std::cout << "Result: " << result << std::endl; // 输出 Result: 6.28
    
    auto vec = getVector();
    std::cout << "Vector: ";
    for (const auto& elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    std::cout << "Factorial of 5: " << factorial(5) << std::endl;
    
    std::map<std::string, int> myMap = {{"one", 1}, {"two", 2}};
    auto first = getFirstElement(myMap);
    std::cout << "First element: " << first.first << " -> " << first.second << std::endl;
    
    auto divResult = divide(10.0, 3);
    std::cout << "10.0 / 3 = " << divResult << std::endl;
    
    return 0;
}
```

### 1.4 注意事项与限制

1. **多个返回语句的类型一致性**：
   ```cpp
   // 正确：所有返回语句推导为同一类型
   auto foo(bool condition) {
       if (condition) {
           return 42;  // int
       }
       return 3.14;   // 错误！与前面的返回类型不一致
   }
   ```

2. **递归函数的限制**：
   ```cpp
   // 错误：没有非递归返回语句来启动推导
   auto fibonacci(int n) {
       if (n <= 1) {
           return n;  // 启动推导，返回类型为 int
       }
       return fibonacci(n - 1) + fibonacci(n - 2);  // 递归调用
   }
   ```

3. **不能用于虚函数**：
   ```cpp
   class Base {
   public:
       // 错误：虚函数不能使用返回类型推导
       virtual auto foo() {
           return 42;
       }
   };
   ```

4. **与模板结合使用时的注意事项**：
   ```cpp
   template<typename T>
   auto process(T t) {
       if (std::is_integral<T>::value) {
           return t + 1;  // 如果T是int，返回int
       }
       return t + 0.5;    // 如果T是double，返回double
   }
   // 注意：如果T是int，第二个return语句会导致编译错误，因为返回类型已经被推导为int
   ```

### 1.5 实际应用场景

1. **简化工厂函数**：
   ```cpp
   class Shape {
   public:
       virtual ~Shape() = default;
       virtual void draw() const = 0;
   };
   
   class Circle : public Shape {
   public:
       void draw() const override { std::cout << "Drawing circle" << std::endl; }
   };
   
   class Square : public Shape {
   public:
       void draw() const override { std::cout << "Drawing square" << std::endl; }
   };
   
   // 工厂函数，根据类型创建不同的形状
   auto createShape(const std::string& type) -> std::unique_ptr<Shape> {
       if (type == "circle") {
           return std::make_unique<Circle>();
       } else if (type == "square") {
           return std::make_unique<Square>();
       }
       return nullptr;
   }
   ```

2. **简化模板函数**：
   ```cpp
   template<typename Container, typename Value>
   auto find(const Container& container, const Value& value) {
       return std::find(container.begin(), container.end(), value);
   }
   
   std::vector<int> vec = {1, 2, 3, 4, 5};
   auto it = find(vec, 3);  // 返回类型自动推导为 std::vector<int>::iterator
   ```

## 2. 泛型 Lambda 表达式 (Generic Lambdas)

### 2.1 简介
C++11 的 Lambda 表达式已经很强大，C++14 则通过泛型 Lambda 进一步提升了其灵活性。泛型 Lambda 可以接受任意类型的参数，而无需显式指定类型，这实际上是编译器为我们生成模板函数的语法糖。

### 2.2 从 C++11 到 C++14 的演变

**C++11:**
```cpp
// C++11 需要为 Lambda 表达式指定参数类型
auto addIntegers = [](int a, int b) {
    return a + b;
};

auto addDoubles = [](double a, double b) {
    return a + b;
};

// 如果需要处理不同类型，必须使用模板函数对象
struct Add {
    template<typename T, typename U>
    auto operator()(T a, U b) const -> decltype(a + b) {
        return a + b;
    }
};
```

**C++14:**
```cpp
// C++14 可以使用 auto 作为参数类型，实现泛型 Lambda
auto add = [](auto a, auto b) {
    return a + b;
};
```

### 2.3 详细示例与应用

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <map>

int main() {
    // 基本泛型 Lambda
    auto genericAdd = [](auto x, auto y) {
        return x + y;
    };
    
    std::cout << "5 + 3 = " << genericAdd(5, 3) << std::endl;                    // 输出 8
    std::cout << "2.5 + 1.5 = " << genericAdd(2.5, 1.5) << std::endl;            // 输出 4.0
    std::cout << "Hello + world = " << genericAdd(std::string("Hello, "), std::string("world!")) << std::endl; // 输出 "Hello, world!"
    
    // 与STL算法结合使用
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 打印所有元素
    std::for_each(numbers.begin(), numbers.end(), [](const auto& n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;
    
    // 计算所有元素的平方
    std::vector<int> squares;
    std::transform(numbers.begin(), numbers.end(), std::back_inserter(squares), 
                  [](auto n) { return n * n; });
    
    std::cout << "Squares: ";
    for (const auto& sq : squares) {
        std::cout << sq << " ";
    }
    std::cout << std::endl;
    
    // 使用泛型Lambda处理不同容器
    auto printContainer = [](const auto& container) {
        for (const auto& elem : container) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    };
    
    std::vector<std::string> words = {"Hello", "world", "from", "C++14"};
    std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};
    
    std::cout << "Words: ";
    printContainer(words);
    
    std::cout << "Map elements: ";
    printContainer(ages);  // 注意：这里会打印键值对，但格式可能不是我们期望的
    
    // 更复杂的泛型Lambda - 比较任意类型
    auto compare = [](const auto& a, const auto& b) {
        if (a < b) return -1;
        if (b < a) return 1;
        return 0;
    };
    
    std::cout << "Compare 5 and 3: " << compare(5, 3) << std::endl;
    std::cout << "Compare \"apple\" and \"banana\": " << compare(std::string("apple"), std::string("banana")) << std::endl;
    
    // 泛型Lambda与可变参数模板结合
    auto printAll = [](const auto&... args) {
        (std::cout << ... << args) << std::endl;  // C++17 折叠表达式
    };
    
    printAll("Hello", " ", "world", "!", 42);
    
    return 0;
}
```

### 2.4 实际应用场景

1. **通用比较函数**：
   ```cpp
   std::vector<std::string> strings = {"apple", "banana", "cherry", "date"};
   
   // 使用泛型Lambda进行排序
   std::sort(strings.begin(), strings.end(), [](const auto& a, const auto& b) {
       return a.length() < b.length();  // 按字符串长度排序
   });
   
   // 按字典序排序
   std::sort(strings.begin(), strings.end(), [](const auto& a, const auto& b) {
       return a < b;
   });
   ```

2. **通用访问器**：
   ```cpp
   std::vector<std::pair<std::string, int>> nameAgePairs = {
       {"Alice", 25}, {"Bob", 30}, {"Charlie", 35}
   };
   
   // 提取所有名称
   std::vector<std::string> names;
   std::transform(nameAgePairs.begin(), nameAgePairs.end(), std::back_inserter(names),
                 [](const auto& pair) { return pair.first; });
   
   // 提取所有年龄
   std::vector<int> ages;
   std::transform(nameAgePairs.begin(), nameAgePairs.end(), std::back_inserter(ages),
                 [](const auto& pair) { return pair.second; });
   ```

3. **通用谓词**：
   ```cpp
   // 检查是否在范围内
   auto isInRange = [](auto value, auto min, auto max) {
       return value >= min && value <= max;
   };
   
   std::vector<int> numbers = {1, 5, 10, 15, 20, 25, 30};
   int count = std::count_if(numbers.begin(), numbers.end(), 
                            [&](auto n) { return isInRange(n, 10, 20); });
   ```

## 3. Lambda 捕获表达式 (Lambda Capture Expressions)

### 3.1 简介
C++11 的 Lambda 捕获只能捕获当前作用域中已存在的变量，C++14 则允许在捕获列表中创建新的变量，并对其进行初始化。这一特性极大地增强了 Lambda 表达式的灵活性，特别是对于移动语义和复杂初始化场景。

### 3.2 从 C++11 到 C++14 的演变

**C++11:**
```cpp
int x = 10;
auto lambda = [x]() { // 只能捕获已存在的变量 x
    return x * 2;
};

// 如果需要修改捕获的变量，必须使用可变Lambda
int y = 5;
auto mutableLambda = [y]() mutable {
    y *= 2;  // 修改的是副本
    return y;
};
```

**C++14:**
```cpp
// 可以创建并初始化新的变量
auto lambda = [x = 10]() { 
    return x * 2;
};

// 移动捕获
auto lambda2 = [ptr = std::make_unique<int>(5)]() {
    // 使用 ptr
    return *ptr;
};

// 引用捕获并初始化
auto lambda3 = [&x = y]() {  // y必须是外部变量
    x *= 2;  // 修改的是y的引用
    return x;
};
```

### 3.3 详细示例与应用

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>
#include <map>

class Resource {
public:
    Resource(const std::string& name) : name_(name) {
        std::cout << "Resource " << name_ << " created" << std::endl;
    }
    
    ~Resource() {
        std::cout << "Resource " << name_ << " destroyed" << std::endl;
    }
    
    void use() const {
        std::cout << "Using resource " << name_ << std::endl;
    }

private:
    std::string name_;
};

int main() {
    // 基本初始化捕获
    auto initCapture = [value = 42]() {
        return value;
    };
    std::cout << "Init capture: " << initCapture() << std::endl;
    
    // 移动捕获
    auto moveCapture = [ptr = std::make_unique<int>(10)]() {
        return *ptr;
    };
    std::cout << "Move capture: " << moveCapture() << std::endl;
    // ptr的所有权已经被移动到lambda表达式内部,所以这里不能再使用ptr
    
    // 捕获复杂对象
    auto resourceCapture = [res = std::make_shared<Resource>("File")]() {
        res->use();
    };
    resourceCapture();
    
    // 引用捕获并初始化
    int external = 5;
    auto refCapture = [&x = external]() {
        x *= 2;
        return x;
    };
    std::cout << "Before ref capture: " << external << std::endl;
    std::cout << "Ref capture result: " << refCapture() << std::endl;
    std::cout << "After ref capture: " << external << std::endl;
    
    // 捕获表达式与泛型Lambda结合
    auto genericCapture = [value = 10](auto x) {
        return x + value;
    };
    std::cout << "Generic capture (int): " << genericCapture(5) << std::endl;
    std::cout << "Generic capture (double): " << genericCapture(3.14) << std::endl;
    
    // 捕获多个变量并进行初始化
    int multiplier = 2;
    auto multiCapture = [base = 10, &mult = multiplier](auto x) {
        return (x + base) * mult;
    };
    std::cout << "Multi capture: " << multiCapture(5) << std::endl;
    
    // 捕获表达式与STL算法结合
    std::vector<std::string> words = {"Hello", "world", "from", "C++14"};
    std::string prefix = ">> ";
    std::string suffix = " <<";
    
    std::for_each(words.begin(), words.end(), 
                 [p = std::move(prefix), s = std::move(suffix)](const std::string& word) {
                     std::cout << p << word << s << std::endl;
                 });
    
    // 捕获表达式用于延迟计算
    std::map<int, std::string> idToName = {
        {1, "Alice"}, {2, "Bob"}, {3, "Charlie"}
    };
    
    int id = 2;
    auto lazyLookup = [map = idToName, id = id]() {
        auto it = map.find(id);
        return it != map.end() ? it->second : "Unknown";
    };
    
    std::cout << "Lazy lookup result: " << lazyLookup() << std::endl;
    
    // 捕获表达式用于复杂初始化
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    auto complexCapture = [sum = std::accumulate(numbers.begin(), numbers.end(), 0)]() {
        return sum;
    };
    std::cout << "Complex capture (sum): " << complexCapture() << std::endl;
    
    return 0;
}
```

### 3.4 捕获表达式的优势

1. **移动行为支持**：
   
   ```cpp
   auto uniquePtr = std::make_unique<int>(42);
   auto lambda = [ptr = std::move(uniquePtr)]() {
       return *ptr;
   };
   // uniquePtr现在是空的，资源所有权已经转移到lambda中
   ```
   
2. **灵活的初始化**：
   ```cpp
   // 在捕获时进行计算
   auto lambda = [result = expensiveCalculation()]() {
       return result;
   };
   ```

3. **避免外部变量修改**：
   ```cpp
   int x = 10;
   auto lambda = [x = x * 2]() {  // 使用x的值初始化新的x
       return x;
   };
   x = 20;  // 修改外部x不会影响lambda内部的x
   ```

4. **引用捕获特定表达式**：
   ```cpp
   std::map<int, std::string> data;
   auto lambda = [&value = data[42]]() {
       value = "Answer";  // 修改map中key为42的值
   };
   ```

### 3.5 实际应用场景

1. **线程安全的资源管理**：
   ```cpp
   std::mutex mtx;
   std::shared_ptr<Resource> resource = std::make_shared<Resource>("Shared");
   
   // 在新线程中使用资源
   std::thread t([res = std::move(resource), &mtx]() {
       std::lock_guard<std::mutex> lock(mtx);
       res->use();
   });
   t.join();
   ```

2. **延迟执行操作**：
   ```cpp
   class DelayedAction {
   public:
       template<typename Func>
       DelayedAction(int delayMs, Func&& func) 
           : timer_([delayMs, f = std::forward<Func>(func)]() {
               std::this_thread::sleep_for(std::chrono::milliseconds(delayMs));
               f();
           }) {}
       
   private:
       std::thread timer_;
   };
   
   // 使用示例
   DelayedAction action(1000, []() {
       std::cout << "Delayed action executed!" << std::endl;
   });
   ```

3. **配置管理**：
   ```cpp
   std::map<std::string, std::string> config = {
       {"host", "example.com"},
       {"port", "8080"},
       {"timeout", "5000"}
   };
   
   // 创建一个带有预解析配置的lambda
   auto connect = [cfg = config]() {
       std::string host = cfg.at("host");
       int port = std::stoi(cfg.at("port"));
       int timeout = std::stoi(cfg.at("timeout"));
       
       std::cout << "Connecting to " << host << ":" << port 
                 << " with timeout " << timeout << "ms" << std::endl;
       // 实际连接代码...
   };
   
   connect();
   ```

## 4. 变量模板 (Variable Templates)

### 4.1 简介
C++14 引入了变量模板，允许我们定义可以参数化的变量。这一特性使得我们可以为不同类型定义相同的变量，而不需要为每种类型单独定义变量。变量模板特别适用于定义常量值，如数学常数。

### 4.2 基本语法与示例

```cpp
template<typename T>
constexpr T pi = T(3.1415926535897932385);

template<typename T>
T circularArea(T r) {
    return pi<T> * r * r;
}
```

### 4.3 详细示例与应用

```cpp
#include <iostream>
#include <complex>
#include <ratio>

// 基本变量模板
template<typename T>
constexpr T pi = T(3.1415926535897932385L);

template<>
constexpr float pi<float> = 3.1415926535f;

template<>
constexpr double pi<double> = 3.1415926535897932385;

template<>
constexpr long double pi<long double> = 3.1415926535897932385L;

// 复数类型的pi
template<typename T>
constexpr std::complex<T> pi_complex = std::complex<T>(pi<T>, T());

// 其他数学常数
template<typename T>
constexpr T e = T(2.7182818284590452353);

template<typename T>
constexpr T golden_ratio = T(1.6180339887498948482);

// 物理常数
template<typename T>
constexpr T speed_of_light = T(299792458.0);  // m/s

template<typename T>
constexpr T planck_constant = T(6.62607015e-34);  // J·s

// 使用标准库的ratio
template<typename T, typename Period = std::ratio<1>>
constexpr T frequency_to_angular_velocity(T freq) {
    return T(2) * pi<T> * freq * Period::num / Period::den;
}

int main() {
    // 使用不同类型的pi
    std::cout << "Pi (float): " << pi<float> << std::endl;
    std::cout << "Pi (double): " << pi<double> << std::endl;
    std::cout << "Pi (long double): " << pi<long double> << std::endl;
    
    // 计算圆面积
    std::cout << "Area of circle with radius 5.0 (float): " 
              << circularArea(5.0f) << std::endl;
    std::cout << "Area of circle with radius 5.0 (double): " 
              << circularArea(5.0) << std::endl;
    
    // 使用复数pi
    auto complex_pi = pi_complex<double>;
    std::cout << "Complex pi: " << complex_pi << std::endl;
    
    // 使用其他数学常数
    std::cout << "e (double): " << e<double> << std::endl;
    std::cout << "Golden ratio (float): " << golden_ratio<float> << std::endl;
    
    // 使用物理常数
    std::cout << "Speed of light: " << speed_of_light<double> << " m/s" << std::endl;
    std::cout << "Planck constant: " << planck_constant<double> << " J·s" << std::endl;
    
    // 使用频率转换函数
    double freq = 50.0;  // Hz
    double angular_vel = frequency_to_angular_velocity<double>(freq);
    std::cout << "Angular velocity for " << freq << " Hz: " 
              << angular_vel << " rad/s" << std::endl;
    
    // 使用毫秒
    double freq_ms = 1000.0;  // mHz (millihertz)
    double angular_vel_ms = frequency_to_angular_velocity<double, std::milli>(freq_ms);
    std::cout << "Angular velocity for " << freq_ms << " mHz: " 
              << angular_vel_ms << " rad/s" << std::endl;
    
    return 0;
}
```



### 4.4 变量模板的优势

1. **类型安全的常量定义**：
   ```cpp
   // 传统方式
   #define PI 3.1415926535897932385  // 不是类型安全的
   
   // 变量模板方式
   template<typename T>
   constexpr T pi = T(3.1415926535897932385);  // 类型安全
   ```

3. **更好的代码可读性**：
   ```cpp
   // 传统方式
   template<typename T, std::size_t N>
   struct ArraySize {
       static constexpr std::size_t value = N;
   };
   
   std::array<int, 5> arr;
   std::cout << "Size: " << ArraySize<int, arr.size()>::value << std::endl;
   
   // 变量模板方式
   template<typename T, std::size_t N>
   constexpr std::size_t array_size_v = N;
   
   std::array<int, 5> arr;
   std::cout << "Size: " << array_size_v<int, arr.size()> << std::endl;
   ```

### 4.6 实际应用场景

1. **科学计算库**：
   ```cpp
   // 定义物理常数
   template<typename T>
   constexpr T gravitational_constant = T(6.67430e-11);  // m^3 kg^-1 s^-2
   
   template<typename T>
   T gravitational_force(T mass1, T mass2, T distance) {
       return gravitational_constant<T> * mass1 * mass2 / (distance * distance);
   }
   ```

2. **图形编程**：
   ```cpp
   // 定义常用颜色
   template<typename T>
   struct Color {
       T r, g, b, a;
   };
   
   template<typename T>
   constexpr Color<T> red = {T(1), T(0), T(0), T(1)};
   
   template<typename T>
   constexpr Color<T> green = {T(0), T(1), T(0), T(1)};
   
   template<typename T>
   constexpr Color<T> blue = {T(0), T(0), T(1), T(1)};
   
   // 使用
   auto pixel = red<float>;
   ```

## 5. `[[deprecated]]` 属性

### 5.1 简介
C++14 引入了标准的 `[[deprecated]]` 属性，用于标记不推荐使用的函数、类、变量等。编译器在遇到被 `[[deprecated]]` 标记的实体时会发出警告，帮助开发者识别并更新使用过时API的代码。

### 5.2 基本语法与示例

```cpp
[[deprecated("Use newFunction() instead")]]
void oldFunction() {
    // ...
}
```

### 5.3 详细示例与应用

```cpp
#include <iostream>
#include <vector>
#include <string>

// 标记函数为已弃用
[[deprecated("Use newPrint() instead for better performance")]]
void oldPrint(const std::string& message) {
    std::cout << "[OLD] " << message << std::endl;
}

void newPrint(const std::string& message) {
    std::cout << "[NEW] " << message << std::endl;
}

// 标记类为已弃用
[[deprecated("Use NewContainer instead, which provides better performance")]]
class OldContainer {
public:
    void add(int item) {
        items_.push_back(item);
    }
    
    int size() const {
        return items_.size();
    }

private:
    std::vector<int> items_;
};

class NewContainer {
public:
    void add(int item) {
        items_.push_back(item);
    }
    
    int size() const {
        return items_.size();
    }
    
    // 新增功能
    void clear() {
        items_.clear();
    }

private:
    std::vector<int> items_;
};

// 标记成员函数为已弃用
class NetworkManager {
public:
    void connect() {
        std::cout << "Connecting to network..." << std::endl;
    }
    
    [[deprecated("Use connect() with timeout parameter instead")]]
    void connectWithoutTimeout() {
        std::cout << "Connecting to network without timeout..." << std::endl;
    }
    
    void connect(int timeoutMs) {
        std::cout << "Connecting to network with timeout: " << timeoutMs << "ms" << std::endl;
    }
};

// 标记变量为已弃用
[[deprecated("Use newConfig instead")]]
const std::string oldConfig = "old_config_value";

const std::string newConfig = "new_config_value";

// 标记枚举值为已弃用
enum class Status {
    OK,
    [[deprecated("Use ERROR_CODE instead")]] ERROR,
    ERROR_CODE
};

// 标记模板为已弃用
template<typename T>
[[deprecated("Use SafeVector<T> instead, which provides bounds checking")]]
class UnsafeVector {
public:
    T& operator[](std::size_t index) {
        return data_[index];  // 无边界检查
    }

private:
    static const std::size_t SIZE = 100;
    T data_[SIZE];
};

template<typename T>
class SafeVector {
public:
    T& operator[](std::size_t index) {
        if (index >= size()) {
            throw std::out_of_range("Index out of range");
        }
        return data_[index];
    }
    
    std::size_t size() const {
        return SIZE;
    }

private:
    static const std::size_t SIZE = 100;
    T data_[SIZE];
};

int main() {
    // 使用已弃用的函数
    oldPrint("This is an old message");  // 编译器会发出警告
    
    // 使用新函数
    newPrint("This is a new message");
    
    // 使用已弃用的类
    OldContainer oldContainer;
    oldContainer.add(1);
    std::cout << "Old container size: " << oldContainer.size() << std::endl;
    
    // 使用新类
    NewContainer newContainer;
    newContainer.add(1);
    std::cout << "New container size: " << newContainer.size() << std::endl;
    
    // 使用已弃用的成员函数
    NetworkManager manager;
    manager.connectWithoutTimeout();  // 编译器会发出警告
    manager.connect(5000);
    
    // 使用已弃用的变量
    std::cout << "Old config: " << oldConfig << std::endl;  // 编译器会发出警告
    std::cout << "New config: " << newConfig << std::endl;
    
    // 使用已弃用的枚举值
    Status status = Status::ERROR;  // 编译器会发出警告
    status = Status::ERROR_CODE;
    
    // 使用已弃用的模板
    UnsafeVector<int> unsafeVec;
    unsafeVec[0] = 42;  // 编译器会发出警告
    
    SafeVector<int> safeVec;
    safeVec[0] = 42;
    
    return 0;
}
```

### 5.4 不同编译器中的支持

`[[deprecated]]` 属性在所有主流编译器中都有良好的支持，但警告的格式和级别可能有所不同：

- **GCC/Clang**: 默认会发出警告，可以使用 `-Wno-deprecated-declarations` 禁用警告
- **MSVC**: 默认会发出警告，可以使用 `/wd4996` 禁用警告
- **Intel C++**: 默认会发出警告

### 5.5 与其他C++属性的对比

C++14还引入了其他属性，如 `[[nodiscard]]`（C++17）和 `[[maybe_unused]]`（C++17）：

```cpp
// C++17
[[nodiscard]] int calculate() {
    return 42;
}

int main() {
    calculate();  // 警告：返回值被忽略
    return 0;
}

// C++17
void function([[maybe_unused]] int param) {
    // 参数未使用，但不会发出警告
}
```

### 5.6 实际应用场景

1. **库版本管理**：
   ```cpp
   // 在库的新版本中标记旧API为已弃用
   namespace LibraryV1 {
       [[deprecated("Use LibraryV2::function() instead")]]
       void function() {
           // 旧实现
       }
   }
   
   namespace LibraryV2 {
       void function() {
           // 新实现
       }
   }
   ```

2. **API迁移**：
   ```cpp
   class Database {
   public:
       // 旧方法
       [[deprecated("Use executeQuery() instead")]]
       bool query(const std::string& sql) {
           // 旧实现
           return executeQuery(sql);
       }
       
       // 新方法
       bool executeQuery(const std::string& sql) {
           // 新实现，支持更多功能
           return true;
       }
   };
   ```

3. **安全更新**：
   ```cpp
   class SecurityManager {
   public:
       // 旧方法，存在安全漏洞
       [[deprecated("Use authenticateSecure() instead, this method is vulnerable to attacks")]]
       bool authenticate(const std::string& username, const std::string& password) {
           // 不安全的实现
           return false;
       }
       
       // 新方法，更安全
       bool authenticateSecure(const std::string& username, const std::string& password) {
           // 安全的实现
           return true;
       }
   };
   ```

## 6. 二进制字面量和数字分隔符

### 6.1 简介
C++14 引入了两个新的数字字面量特性，使代码更具可读性和表达力：
- **二进制字面量**：使用 `0b` 或 `0B` 前缀来表示二进制字面量
- **数字分隔符**：允许在数字字面量中插入单引号 `'` 作为分隔符，以提高可读性

### 6.2 基本语法与示例

```cpp
// 二进制字面量
int binary = 0b10101010;  // 十进制 170

// 数字分隔符
long long largeNumber = 1'000'000'000'000;  // 1万亿
double pi = 3.141'592'653'589'793'238'462;  // 更易读的pi值
```

### 6.3 详细示例与应用

```cpp
#include <iostream>
#include <bitset>
#include <iomanip>

int main() {
    // 二进制字面量
    int binaryValue = 0b1101;             // 二进制表示的 13
    unsigned char flags = 0b10101010;     // 位标志
    
    std::cout << "Binary value 0b1101 = " << binaryValue << std::endl;
    std::cout << "Binary value 0b10101010 = " << static_cast<int>(flags) << std::endl;
    
    // 使用bitset显示二进制表示
    std::cout << "Binary representation of 13: " << std::bitset<8>(binaryValue) << std::endl;
    std::cout << "Binary representation of flags: " << std::bitset<8>(flags) << std::endl;
    
    // 数字分隔符 - 整数
    int population = 7'800'000'000;       // 世界人口约78亿
    long distanceToSun = 149'597'870'700; // 地球到太阳的距离（米）
    
    std::cout << "World population: " << population << std::endl;
    std::cout << "Distance to Sun: " << distanceToSun << " meters" << std::endl;
    
    // 数字分隔符 - 浮点数
    double pi = 3.141'592'653'589'793'238'462;
    double avogadro = 6.022'140'76e23;    // 阿伏伽德罗常数
    
    std::cout << std::setprecision(15);
    std::cout << "Pi: " << pi << std::endl;
    std::cout << "Avogadro's number: " << avogadro << std::endl;
    
    // 数字分隔符 - 二进制和十六进制
    int binaryWithSeparator = 0b1010'1100'1111'0000;
    int hexWithSeparator = 0xAC'F0;
    
    std::cout << "Binary with separator: " << binaryWithSeparator 
              << " (0b" << std::bitset<16>(binaryWithSeparator) << ")" << std::endl;
    std::cout << "Hex with separator: " << hexWithSeparator 
              << " (0x" << std::hex << hexWithSeparator << std::dec << ")" << std::endl;
    
    // 位操作示例
    unsigned int statusRegister = 0b1100'1010'1111'0101;
    
    // 提取特定位
    unsigned int errorCode = (statusRegister >> 4) & 0b1111;
    std::cout << "Error code: " << errorCode << std::endl;
    
    // 设置特定位
    statusRegister |= 0b0000'0000'0000'1000;  // 设置第3位
    std::cout << "Status register after setting bit 3: 0b" 
              << std::bitset<16>(statusRegister) << std::endl;
    
    // 清除特定位
    statusRegister &= ~0b0000'0000'0000'1000;  // 清除第3位
    std::cout << "Status register after clearing bit 3: 0b" 
              << std::bitset<16>(statusRegister) << std::endl;
    
    // 使用二进制字面量定义位掩码
    const unsigned int READ_FLAG = 0b0000'0001;
    const unsigned int WRITE_FLAG = 0b0000'0010;
    const unsigned int EXECUTE_FLAG = 0b0000'0100;
    
    unsigned int filePermissions = READ_FLAG | WRITE_FLAG;
    std::cout << "File permissions: 0b" << std::bitset<8>(filePermissions) << std::endl;
    
    // 检查权限
    if (filePermissions & READ_FLAG) {
        std::cout << "File has read permission" << std::endl;
    }
    
    if (filePermissions & WRITE_FLAG) {
        std::cout << "File has write permission" << std::endl;
    }
    
    if (!(filePermissions & EXECUTE_FLAG)) {
        std::cout << "File does not have execute permission" << std::endl;
    }
    
    return 0;
}
```

### 6.4 不同进制字面量的对比

```cpp
#include <iostream>

int main() {
    // 十进制
    int decimal = 42;
    
    // 十六进制 (C++98)
    int hexadecimal = 0x2A;
    
    // 八进制 (C++98)
    int octal = 052;
    
    // 二进制 (C++14)
    int binary = 0b101010;
    
    std::cout << "Decimal: " << decimal << std::endl;
    std::cout << "Hexadecimal: 0x" << std::hex << hexadecimal << std::dec << std::endl;
    std::cout << "Octal: 0" << std::oct << octal << std::dec << std::endl;
    std::cout << "Binary: 0b" << std::bitset<8>(binary) << std::endl;
    
    return 0;
}
```

### 6.5 数字分隔符的使用规则

1. **分隔符的位置**：
   ```cpp
   // 正确
   int a = 1'000'000;
   double b = 3.141'592;
   int c = 0b1010'1100;
   
   // 错误 - 不能在开头或结尾
   // int d = '1000;
   // int e = 1000';
   
   // 错误 - 不能连续使用
   // int f = 1''000''000;
   
   // 错误 - 不能在小数点前后
   // double g = 3.'141592;
   // double h = 3.141592';
   ```

2. **不同进制中的使用**：
   ```cpp
   // 十进制
   int decimal = 1'234'567;
   
   // 十六进制
   int hex = 0x12'34'AB'CD;
   
   // 二进制
   int binary = 0b1100'1010'1111'0000;
   
   // 科学计数法
   double scientific = 1.602'176'634e-19;  // 基本电荷
   ```

### 6.6 实际应用场景

1. **位操作和硬件编程**：
   ```cpp
   // 定义寄存器位掩码
   const unsigned int STATUS_READY = 0b0000'0001;
   const unsigned int STATUS_ERROR = 0b0000'0010;
   const unsigned int STATUS_BUSY = 0b0000'0100;
   
   // 检查状态
   unsigned int status = 0b0000'0011;  // READY和ERROR位被设置
   
   if (status & STATUS_READY) {
       std::cout << "Device is ready" << std::endl;
   }
   
   if (status & STATUS_ERROR) {
       std::cout << "Device has error" << std::endl;
   }
   ```

2. **金融计算**：
   ```cpp
   // 使用分隔符提高大数字的可读性
   long long nationalDebt = 28'000'000'000'000;  // 28万亿美元
   double interestRate = 3.25'%;                 // 3.25%
   
   std::cout << "National debt: $" << nationalDebt << std::endl;
   std::cout << "Interest rate: " << interestRate << "%" << std::endl;
   ```

3. **科学计算**：
   ```cpp
   // 物理常数
   double speedOfLight = 299'792'458.0;          // m/s
   double planckConstant = 6.626'070'15e-34;      // J·s
   double electronMass = 9.109'383'701'5e-31;    // kg
   
   std::cout << "Speed of light: " << speedOfLight << " m/s" << std::endl;
   std::cout << "Planck constant: " << planckConstant << " J·s" << std::endl;
   std::cout << "Electron mass: " << electronMass << " kg" << std::endl;
   ```

4. **网络编程**：
   ```cpp
   // IP地址和端口号
   unsigned int ipAddress = 0b11000000'10101000'00000001'00000001;  // 192.168.1.1
   unsigned short port = 8'080;                                     // HTTP备用端口
   
   std::cout << "IP Address: " << 
        ((ipAddress >> 24) & 0xFF) << "." <<
        ((ipAddress >> 16) & 0xFF) << "." <<
        ((ipAddress >> 8) & 0xFF) << "." <<
        (ipAddress & 0xFF) << std::endl;
   std::cout << "Port: " << port << std::endl;
   ```

## 7. `std::make_unique`

### 7.1 简介
C++11 引入了 `std::make_shared` 来更安全地创建 `std::shared_ptr`，C++14 则补充了 `std::make_unique` 来创建 `std::unique_ptr`。`std::make_unique` 是一个工厂函数，用于创建 `std::unique_ptr` 并安全地管理其生命周期。

### 7.2 基本语法与示例

```cpp
#include <memory>

// 基本用法
auto ptr = std::make_unique<int>(42);

// 创建对象并传递参数
auto obj = std::make_unique<MyClass>(arg1, arg2);
```

### 7.3 详细示例与应用

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

class Resource {
public:
    Resource(const std::string& name) : name_(name) {
        std::cout << "Resource " << name_ << " created" << std::endl;
    }
    
    ~Resource() {
        std::cout << "Resource " << name_ << " destroyed" << std::endl;
    }
    
    void use() const {
        std::cout << "Using resource " << name_ << std::endl;
    }
    
    void setName(const std::string& name) {
        name_ = name;
    }
    
    const std::string& getName() const {
        return name_;
    }

private:
    std::string name_;
};

class Widget {
public:
    Widget(int id, const std::string& name) 
        : id_(id), name_(name), resource_(std::make_unique<Resource>("WidgetResource")) {
        std::cout << "Widget " << name_ << " (ID: " << id_ << ") created" << std::endl;
    }
    
    ~Widget() {
        std::cout << "Widget " << name_ << " (ID: " << id_ << ") destroyed" << std::endl;
    }
    
    void operate() {
        std::cout << "Widget " << name_ << " operating with resource ";
        resource_->use();
    }

private:
    int id_;
    std::string name_;
    std::unique_ptr<Resource> resource_;
};

int main() {
    // 基本用法
    auto intPtr = std::make_unique<int>(42);
    std::cout << "Value: " << *intPtr << std::endl;
    
    // 创建对象
    auto resource = std::make_unique<Resource>("File");
    resource->use();
    
    // 使用unique_ptr管理Widget
    auto widget = std::make_unique<Widget>(1, "SuperWidget");
    widget->operate();
    
    // unique_ptr的所有权转移
    std::cout << "\nTransferring ownership:" << std::endl;
    auto widget2 = std::move(widget);
    if (!widget) {
        std::cout << "widget is now null" << std::endl;
    }
    widget2->operate();
    
    // 在容器中使用unique_ptr
    std::cout << "\nUsing unique_ptr in container:" << std::endl;
    std::vector<std::unique_ptr<Resource>> resources;
    
    resources.push_back(std::make_unique<Resource>("Resource1"));
    resources.push_back(std::make_unique<Resource>("Resource2"));
    resources.push_back(std::make_unique<Resource>("Resource3"));
    
    // 遍历容器
    for (const auto& res : resources) {
        res->use();
    }
    
    // 移动元素
    std::cout << "\nMoving elements:" << std::endl;
    auto movedResource = std::move(resources.back());
    resources.pop_back();
    
    movedResource->use();
    std::cout << "Container size after move: " << resources.size() << std::endl;
    
    // 使用自定义删除器
    std::cout << "\nUsing custom deleter:" << std::endl;
    auto customDeleter = [](Resource* res) {
        std::cout << "Custom deleter called for " << res->getName() << std::endl;
        delete res;
    };
    
    std::unique_ptr<Resource, decltype(customDeleter)> customResource(
        new Resource("CustomResource"), customDeleter);
    
    // 使用make_unique创建数组
    std::cout << "\nCreating array with make_unique:" << std::endl;
    auto intArray = std::make_unique<int[]>(5);
    
    for (int i = 0; i < 5; ++i) {
        intArray[i] = i * 10;
    }
    
    for (int i = 0; i < 5; ++i) {
        std::cout << intArray[i] << " ";
    }
    std::cout << std::endl;
    
    // make_unique与异常安全
    std::cout << "\nException safety with make_unique:" << std::endl;
    
    class MayThrow {
    public:
        MayThrow(bool shouldThrow) : shouldThrow_(shouldThrow) {
            if (shouldThrow_) {
                throw std::runtime_error("Exception in constructor");
            }
            std::cout << "MayThrow created successfully" << std::endl;
        }
        
        ~MayThrow() {
            std::cout << "MayThrow destroyed" << std::endl;
        }

    private:
        bool shouldThrow_;
    };
    
    class UsesMayThrow {
    public:
        UsesMayThrow(bool shouldThrow) 
            : resource_(std::make_unique<Resource>("UsesMayThrowResource")) {
            std::cout << "UsesMayThrow creating MayThrow..." << std::endl;
            mayThrow_ = std::make_unique<MayThrow>(shouldThrow);
            std::cout << "UsesMayThrow created successfully" << std::endl;
        }
        
        ~UsesMayThrow() {
            std::cout << "UsesMayThrow destroyed" << std::endl;
        }

    private:
        std::unique_ptr<Resource> resource_;
        std::unique_ptr<MayThrow> mayThrow_;
    };
    
    try {
        UsesMayThrow obj(false);  // 不会抛出异常
    } catch (const std::exception& e) {
        std::cerr << "Exception caught: " << e.what() << std::endl;
    }
    
    try {
        UsesMayThrow obj(true);  // 会抛出异常
    } catch (const std::exception& e) {
        std::cerr << "Exception caught: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 7.4 `std::make_unique` 的优势

1. **异常安全**：
   ```cpp
   // 不安全的方式
   void foo() {
       Resource* r = new Resource("r1");  // 如果这里抛出异常，内存泄漏
       std::unique_ptr<Resource> r1(r);
       std::unique_ptr<Resource> r2(new Resource("r2"));  // 如果这里抛出异常，r1泄漏
   }
   
   // 安全的方式
   void foo() {
       auto r1 = std::make_unique<Resource>("r1");
       auto r2 = std::make_unique<Resource>("r2");  // 如果这里抛出异常，r1会被正确释放
   }
   ```

2. **代码简洁性**：
   ```cpp
   // 冗长的方式
   std::unique_ptr<Resource> ptr(new Resource("example"));
   
   // 简洁的方式
   auto ptr = std::make_unique<Resource>("example");
   ```

3. **避免内存泄漏**：
   ```cpp
   // 潜在的内存泄漏
   foo(std::unique_ptr<Resource>(new Resource("r1")), 
       std::unique_ptr<Resource>(new Resource("r2")));
   // 如果编译器顺序是 new Resource("r1") -> new Resource("r2") -> unique_ptr构造
   // 并且第二个new抛出异常，第一个Resource会泄漏
   
   // 安全的方式
   foo(std::make_unique<Resource>("r1"), 
       std::make_unique<Resource>("r2"));
   ```

4. **性能考虑**：
   ```cpp
   // make_unique通常比直接使用new更高效
   // 因为它只需要一次内存分配，而new+unique_ptr构造可能需要两次
   ```

### 7.5 `std::make_unique` 与 `std::make_shared` 的对比

```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource(const std::string& name) : name_(name) {
        std::cout << "Resource " << name_ << " created" << std::endl;
    }
    
    ~Resource() {
        std::cout << "Resource " << name_ << " destroyed" << std::endl;
    }
    
    void use() const {
        std::cout << "Using resource " << name_ << std::endl;
    }

private:
    std::string name_;
};

int main() {
    // 使用make_unique
    std::cout << "Using make_unique:" << std::endl;
    auto uniqueResource = std::make_unique<Resource>("UniqueResource");
    uniqueResource->use();
    
    // 使用make_shared
    std::cout << "\nUsing make_shared:" << std::endl;
    auto sharedResource = std::make_shared<Resource>("SharedResource");
    sharedResource->use();
    
    // 复制shared_ptr
    std::cout << "\nCopying shared_ptr:" << std::endl;
    auto sharedResource2 = sharedResource;
    sharedResource2->use();
    
    // 尝试复制unique_ptr - 编译错误
    // auto uniqueResource2 = uniqueResource;  // 错误：unique_ptr不能复制
    
    // 移动unique_ptr
    std::cout << "\nMoving unique_ptr:" << std::endl;
    auto uniqueResource2 = std::move(uniqueResource);
    if (!uniqueResource) {
        std::cout << "uniqueResource is now null" << std::endl;
    }
    uniqueResource2->use();
    
    return 0;
}
```

### 7.6 实际应用场景

1. **工厂模式**：
   ```cpp
   class Shape {
   public:
       virtual ~Shape() = default;
       virtual void draw() const = 0;
   };
   
   class Circle : public Shape {
   public:
       Circle(double radius) : radius_(radius) {}
       void draw() const override {
           std::cout << "Drawing circle with radius " << radius_ << std::endl;
       }
   private:
       double radius_;
   };
   
   class Square : public Shape {
   public:
       Square(double side) : side_(side) {}
       void draw() const override {
           std::cout << "Drawing square with side " << side_ << std::endl;
       }
   private:
       double side_;
   };
   
   enum class ShapeType { Circle, Square };
   
   std::unique_ptr<Shape> createShape(ShapeType type, double param) {
       switch (type) {
           case ShapeType::Circle:
               return std::make_unique<Circle>(param);
           case ShapeType::Square:
               return std::make_unique<Square>(param);
           default:
               return nullptr;
       }
   }
   
   // 使用
   auto shape = createShape(ShapeType::Circle, 5.0);
   if (shape) {
       shape->draw();
   }
   ```

2. **资源管理**：
   ```cpp
   class FileHandler {
   public:
       FileHandler(const std::string& filename) 
           : file_(std::make_unique<std::fstream>(filename, std::ios::in | std::ios::out)) {
           if (!file_->is_open()) {
               throw std::runtime_error("Failed to open file: " + filename);
           }
       }
       
       void write(const std::string& data) {
           *file_ << data;
       }
       
       std::string read() {
           std::string content;
           *file_ >> content;
           return content;
       }
       
   private:
       std::unique_ptr<std::fstream> file_;
   };
   ```

3. **Pimpl 模式**：
   ```cpp
   // Widget.h
   class Widget {
   public:
       Widget();
       ~Widget();
       void doSomething();
   private:
       class Impl;
       std::unique_ptr<Impl> pimpl_;
   };
   
   // Widget.cpp
   class Widget::Impl {
   public:
       void doSomething() {
           std::cout << "Doing something in implementation" << std::endl;
       }
   };
   
   Widget::Widget() : pimpl_(std::make_unique<Impl>()) {}
   Widget::~Widget() = default;  // 即使是默认实现也需要在.cpp文件中定义
   
   void Widget::doSomething() {
       pimpl_->doSomething();
   }
   ```

## 8. 总结

C++14虽然是一个相对较小的更新，但它带来的改进却非常实用，主要体现在以下几个方面：

### 8.1 提高代码的简洁性和可读性

- **函数返回类型推导**：简化了函数定义，特别是对于返回复杂类型或模板类型的函数，使代码更加简洁易懂。
- **泛型Lambda表达式**：允许Lambda参数使用auto关键字，使Lambda表达式更加灵活，减少了模板函数对象的编写。
- **数字分隔符**：允许在数字字面量中插入单引号作为分隔符，提高了大数字的可读性。

### 8.2 增强泛型编程能力

- **变量模板**：允许定义可以参数化的变量，简化了常量定义和模板元编程。
- **泛型Lambda表达式**：使Lambda表达式能够接受任意类型的参数，增强了泛型编程的能力。
- **编译期整数序列**：提供了强大的编译期编程工具，用于生成索引序列、展开参数包等。

### 8.3 提升开发效率

- **Lambda捕获表达式**：允许在捕获列表中创建新的变量，支持移动捕获，提高了Lambda表达式的灵活性。
- **std::make_unique**：提供了创建std::unique_ptr的工厂函数，简化了内存管理，提高了异常安全性。
- **[[deprecated]]属性**：允许标记不推荐使用的代码，帮助开发者识别并更新使用过时API的代码。

### 8.4 更好的资源管理

- **std::make_unique**：与std::make_shared一起，提供了更安全的内存管理方式，减少了内存泄漏的风险。
- **Lambda捕获表达式**：特别是移动捕获，使得资源管理更加灵活和安全。

### 8.5 更好的标记过时API

- **[[deprecated]]属性**：提供了一种标准的方式来标记过时的API，帮助开发者进行代码维护和升级。

### 8.6 C++14与C++11、C++17的关系

C++14可以看作是C++11的完善和扩展，它修复了C++11中的一些不便之处，并添加了一些实用的新特性。同时，C++14也为C++17和C++20中的更大改进奠定了基础。

- **C++11引入了现代C++的基础**：包括Lambda表达式、右值引用、移动语义、智能指针等。
- **C++14完善了这些基础**：通过函数返回类型推导、泛型Lambda等特性，使这些基础更加易用。
- **C++17和C++20进一步扩展**：在这些基础上添加了更多高级特性，如结构化绑定、if constexpr、概念等。

通过本节课的学习，希望大家能够掌握C++14的新特性，并在实际开发中灵活运用，写出更高效、更优雅的代码。C++14虽然不像C++11那样是一次革命性的更新，但它确实为C++程序员提供了许多实用工具，使得代码编写更加便捷和高效。

## 10. 作业

### 作业要求

编写一个函数 `processContainer`，接受一个容器（如 `std::vector`、`std::list`、`std::set` 等）和一个泛型 Lambda 表达式作为参数。该函数使用给定的 Lambda 表达式处理容器中的每个元素。

具体要求：
1. `processContainer` 函数的第一个参数可以是任意类型的容器，只要该容器支持迭代器。
2. `processContainer` 函数的第二个参数是一个泛型 Lambda 表达式，该 Lambda 表达式接受一个容器元素的引用作为参数（不需要修改可以传 const 引用），可以对元素进行任意操作（例如，打印、修改、计算等）。
3. 演示如何使用不同的容器和不同的 Lambda 表达式来调用 `processContainer` 函数。至少演示三种不同的使用情况：
   - 打印容器内容
   - 将容器内所有元素翻倍（对于数字）或者转换为大写（对于 `std::string`）
   - 计算容器中所有元素的总和（对于数字）或总长度（对于 `std::string`）

### 参考实现

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <set>
#include <string>
#include <algorithm>
#include <numeric>

// processContainer 函数
template<typename Container, typename Callable>
void processContainer(Container& container, Callable operation) {
    // 使用 auto&& 可以兼容左值和右值引用
    for(auto&& element : container) {
        operation(element);
    }
}

int main() {
    // 准备测试数据
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::list<std::string> words = {"hello", "world", "generic", "lambda"};
    std::set<double> doubles = {1.1, 2.2, 3.3, 4.4, 5.5};
    
    // 示例1: 打印容器内容
    std::cout << "=== Printing containers ===" << std::endl;
    
    std::cout << "Numbers: ";
    processContainer(numbers, [](const auto& x) {
        std::cout << x << " ";
    });
    std::cout << std::endl;
    
    std::cout << "Words: ";
    processContainer(words, [](const auto& str) {
        std::cout << str << " ";
    });
    std::cout << std::endl;
    
    std::cout << "Doubles: ";
    processContainer(doubles, [](const auto& d) {
        std::cout << d << " ";
    });
    std::cout << std::endl;
    
    // 示例2: 将数字翻倍, 字符串转大写
    std::cout << "\n=== Modifying containers ===" << std::endl;
    
    processContainer(numbers, [](auto& x) {
        x *= 2;
    });
    
    processContainer(words, [](auto& str) {
        std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    });
    
    // 打印修改后的容器
    std::cout << "Doubled numbers: ";
    processContainer(numbers, [](const auto& x) {
        std::cout << x << " ";
    });
    std::cout << std::endl;
    
    std::cout << "Uppercase words: ";
    processContainer(words, [](const auto& str) {
        std::cout << str << " ";
    });
    std::cout << std::endl;
    
    // 示例3: 计算数字的总和，字符串的总长度
    std::cout << "\n=== Calculating aggregates ===" << std::endl;
    
    int sum = 0;
    processContainer(numbers, [&sum](const auto& x) {
        sum += x;
    });
    std::cout << "Sum of numbers: " << sum << std::endl;
    
    size_t totalLength = 0;
    processContainer(words, [&totalLength](const auto& str) {
        totalLength += str.length();
    });
    std::cout << "Total length of words: " << totalLength << std::endl;
    
    double sumDoubles = 0.0;
    processContainer(doubles, [&sumDoubles](const auto& d) {
        sumDoubles += d;
    });
    std::cout << "Sum of doubles: " << sumDoubles << std::endl;
    
    // 额外示例：使用泛型Lambda进行条件过滤
    std::cout << "\n=== Conditional processing ===" << std::endl;
    
    // 只处理偶数
    std::cout << "Even numbers: ";
    processContainer(numbers, [](const auto& x) {
        if (x % 2 == 0) {
            std::cout << x << " ";
        }
    });
    std::cout << std::endl;
    
    // 只处理长度大于5的字符串
    std::cout << "Long words: ";
    processContainer(words, [](const auto& str) {
        if (str.length() > 5) {
            std::cout << str << " ";
        }
    });
    std::cout << std::endl;
    
    return 0;
}
```
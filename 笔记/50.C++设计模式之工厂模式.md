# **C++设计模式之工厂模式**

## **1. 引言：一切混乱的开始**

### 1.1 痛点：失控的“对象创建”代码 

同学们，想象一下，你是一个软件世界的项目经理，你的任务是写一个客户端程序，让用户能选择并展示不同品牌的手机。最直观的写法是什么？没错，就是 `if-else` 大法！

```cpp
#include <iostream>
#include <string>
using namespace std;

class iPhone { /* ... */ };
class Huawei { /* ... */ };
// 假如未来还有 Xiaomi, Samsung, GooglePixel...豆包手机

void client() {
    string phoneType;
    cin >> phoneType;
    if (phoneType == "iPhone") {
        iPhone* phone = new iPhone(); // 客户端直接依赖 iPhone 类
        // ... 使用 phone ...
        delete phone;
    } else if (phoneType == "Huawei") {
        Huawei* phone = new Huawei(); // 客户端直接依赖 Huawei 类
        // ... 使用 phone ...
        delete phone;
    } else {
      
    }
    // ... 未来新增手机，就要在这里无尽地 else if ...
}
```

**我们遇到了两个致命的问题：**

*   **高度耦合：** 客户端代码（使用者）与 `iPhone`、`Huawei` 这些具体产品类（被创建者）死死地绑在了一起。客户端代码仿佛在喊：“我不仅要用手机，还得知道每款手机是怎么造出来的 (`new`)！” 这太不合理了。
*   **违反开闭原则（OCP）：** 这是软件设计的金科玉律——**对扩展开放，对修改关闭**。现在每当我们要增加一款新手机（比如 `Xiaomi`），就必须回来**修改** `client` 函数的 `if-else` 逻辑。我们的代码变得僵化、脆弱，难以维护。

### 1.2 核心思想

**工厂模式**的核心思想就像现实世界一样：**“把复杂的创建过程，交给专业的工厂。”**

> **工厂模式：** 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。

简单来说，就是将**对象的创建逻辑**从客户端代码中剥离出来，封装到一个专门的“工厂”角色中。客户端（使用者）不再关心对象如何创建，只负责向工厂“下订单”，然后获取产品。

**🎯 我们的目标：**

*   **创建与使用分离：** 客户端负责“使用”，工厂负责“创建”。
*   **降低耦合度：** 客户端不再依赖具体产品类，只依赖抽象的产品和工厂。
*   **提高扩展性：** 增加新产品时，尽量不修改现有代码。

### 1.3 工厂模式

1.  **简单工厂模式 (Simple Factory)**
2.  **工厂方法模式 (Factory Method)**
3.  **抽象工厂模式 (Abstract Factory)**

---

## **2. 简单工厂模式**

### 2.1 需求场景
我们来解决最初的问题：客户端只想通过一个字符串（如 "iPhone"）就得到对应的手机对象，不想知道 `new` 的细节。

### 2.2 解决方案：引入一个万能的工厂类

**定义：** 简单工厂模式（也叫静态工厂方法模式）定义了一个工厂类，它根据传入的参数来动态决定应该创建哪一个产品类的实例。

**💡 就像一个手机店的店员：** 你告诉他要“苹果”，他就从仓库里拿出一部 iPhone 给你。你不用关心这部手机在哪个货架，是怎么放进去的。

#### 2.2.1 角色设计

*   **产品抽象层 (Product):** 定义所有手机的公共标准（接口），比如 `show()`。
*   **具体产品 (ConcreteProduct):** 实现了这个标准的具体手机，如 `iPhone`、`Huawei`。
*   **工厂 (Factory):** 核心角色！负责接收订单（参数），并生产出具体的手机。

#### 2.2.2 C++代码实现

```cpp
#include <iostream>
#include <string>
using namespace std;


class Phone {
public:
    virtual void show() = 0;
    virtual ~Phone() { cout << "Phone destroyed." << endl; }
};

class iPhone : public Phone { /* ... */ };
class Huawei : public Phone { /* ... */ };

class PhoneFactory {
public:
    // 通常是静态方法，方便客户端直接通过类名调用，无需创建工厂实例
    static Phone* createPhone(const string& brand) {
        if (brand == "iPhone") {
            return new iPhone();
        } else if (brand == "Huawei") {
            return new Huawei();
        }
        // 如果未来有更多品牌需要在这个地方增加
        return nullptr; // 无效生产
    }
};

void client() {
    string brand;
    cout << "Enter phone brand (iPhone/Huawei): ";
    cin >> brand;

    Phone* phone = PhoneFactory::createPhone(brand); 
    
    if (phone) {
        phone->show();
        delete phone;
    } else {
        cout << "Sorry, we don't produce this brand." << endl;
    }
}
```

### 2.3 效果分析

#### 2.3.1 优点
*   **责任分离：** 创建的责任从客户端转移到了工厂，各司其职。
*   **解耦：** 客户端只依赖 `Phone` 抽象和 `PhoneFactory`，不再认识 `iPhone`、`Huawei` 这些具体类。

#### 2.3.2 缺点
*   **违反开闭原则：** 这是它的**致命伤**。当我们要新增 `Xiaomi` 手机时，必须**修改** `PhoneFactory` 的 `createPhone` 方法，在里面增加一个 `else if`。
*   **工厂职责过重：** 所有的产品创建逻辑都挤在这个“小作坊”里。产品线一多，这个工厂类会变成一个难以维护的“上帝类”(God Class)。

### 2.4 适用场景
*   产品种类很少，且未来基本不会增加。
*   只想对客户端隐藏创建细节，对扩展性要求不高。

---

## **3. 工厂方法模式**

### 3.1 问题演进
我们的“小作坊”模式在扩展面前不堪一击。如何在不惊动现有工厂和产品的情况下，优雅地增加新产品线呢？

### 3.2 解决方案：将“工厂”也抽象化！

**定义：** 工厂方法模式定义了一个创建对象的抽象方法，但将这个方法的实现推迟到子类中。每个子类工厂负责创建一个具体的产品。

**💡 就像开设品牌专卖店：** 不再有一个万能的手机店。而是有一个“手机工厂”的**标准**（抽象工厂），然后有 `iPhone专卖店`（具体工厂）和 `Huawei专卖店`（具体工厂）。`iPhone专卖店` 只负责生产iPhone，`Huawei专卖店` 只负责生产Huawei手机。

#### 3.2.1 角色设计
这次我们有了平行的两套继承体系：
*   **产品体系：** `Phone` (抽象) -> `iPhone`, `Huawei` (具体)
*   **工厂体系：** `PhoneFactory` (抽象) -> `iPhoneFactory`, `HuaweiFactory` (具体)

#### 3.2.2 C++代码实现

```cpp
#include <iostream>

class iPhone : public Phone { /* ... */ };
class Huawei : public Phone { /* ... */ };

class PhoneFactory {
public:
    // 定义一个纯虚的“工厂方法”
    virtual Phone* createPhone() = 0; 
    virtual ~PhoneFactory() { cout << "Factory destroyed." << endl; }
};

class iPhoneFactory : public PhoneFactory {
public:
    Phone* createPhone() override {
        cout << "iPhone factory is producing an iPhone..." << endl;
        return new iPhone();
    }
};

class HuaweiFactory : public PhoneFactory {
public:
    Phone* createPhone() override {
        cout << "Huawei factory is producing a Huawei phone..." << endl;
        return new Huawei();
    }
};

void client() {
    string brand;
    cout << "Enter brand to open its factory (iPhone/Huawei): ";
    cin >> brand;

    PhoneFactory* factory = nullptr; // 指向“手机工厂”标准的指针

    // 客户端现在选择的是工厂，而不是产品
    if (brand == "iPhone") {
        factory = new iPhoneFactory(); 
    } else if (brand == "Huawei") {
        factory = new HuaweiFactory();
    } 
    // ... 如果要支持新品牌，这里的 if-else 怎么办？
    // 注：实际应用中，这里会用反射、配置文件或更高级的技巧来消除if-else。
    // 但就模式本身而言，创建工厂的逻辑依旧存在。

    if (factory) {
        Phone* phone = factory->createPhone(); 
        phone->show();

        delete phone;
        delete factory;
    } else {
        cout << "No corresponding factory found!" << endl;
    }
}
```

### 3.3 效果分析

#### 3.3.1 优点
*   **完美符合开闭原则：** 如果要新增 `Xiaomi` 手机，我们只需：
    1.  新增 `Xiaomi` 产品类。
    2.  新增 `XiaomiFactory` 工厂类。
    客户端和所有现有代码**完全无需修改**！扩展性极佳。
*   **职责单一：** 每个具体工厂只负责生产一种产品，职责清晰。

#### 3.3.2 缺点
*   **类爆炸：** 每增加一个产品，就需要对应增加一个工厂类。系统中类的数量会成倍增长，增加了系统的复杂度和代码量。
*   **无法处理产品族：** 一个工厂只能生产一种产品。如果我想生产“苹果全家桶”（手机+耳机），工厂方法模式就无能为力了。

### 3.4 适用场景
*   当你需要一个扩展性强的系统，未来会频繁增加新产品。
*   当一个类不知道它所必须创建的对象的类时（例如，由子类来指定创建的对象）。

---

## **4. 抽象工厂模式：构建生态的“品牌旗舰店”**

### 4.1 问题再升级
市场竞争激烈，单卖手机已经不够了。现在要求我们的工厂不仅能生产手机，还要能生产配套的耳机，并且**必须保证是同一品牌**（不能出现用iPhone配华为耳机的情况）。这就是“产品族”的概念。

> **产品族 (Product Family):** 位于不同产品等级结构中，功能相关联的产品组成的集合。
> *   苹果产品族：iPhone (手机), AirPods (耳机)
> *   华为产品族：Huawei Phone (手机), FreeBuds (耳机)

工厂方法模式一个工厂只能创建一个产品，显然无法胜任。

### 4.2 解决方案：抽象工厂定义产品线

**定义：** 抽象工厂模式提供一个接口，用于创建**一系列相关或相互依赖的对象**（即一个产品族），而无需指定它们具体的类。

**💡 就像品牌旗舰店：** 苹果旗舰店（`AppleFactory`）里有专门的柜台，一个用来生产 `iPhone`，一个用来生产 `AirPods`。你只要走进这家店，就能买到一整套苹果生态的产品，绝不会买到华为的东西。

#### 4.2.1 角色设计
*   **产品抽象层：** 现在有多个了，`Phone` 和 `Earphone`。
*   **具体产品：** 也分为两组，`iPhone`/`Huawei` 和 `AirPods`/`FreeBuds`。
*   **抽象工厂：** 定义了**一整条产品线**的创建接口，如 `createPhone()` 和 `createEarphone()`。
*   **具体工厂：** 实现这条产品线，负责创建**一个完整产品族**的所有产品。

#### 4.2.2 C++代码实现

```cpp
#include <iostream>

class iPhone : public Phone { /* ... */ };
class Huawei : public Phone { /* ... */ };

class TechFactory {
public:
    virtual Phone* createPhone() = 0;
    virtual Earphone* createEarphone() = 0;
    virtual ~TechFactory() {}
};

class AppleFactory : public TechFactory {
public:
    Phone* createPhone() override { return new iPhone(); }
    Earphone* createEarphone() override { return new AirPods(); }
};

class HuaweiFactory : public TechFactory {
public:
    Phone* createPhone() override { return new Huawei(); }
    Earphone* createEarphone() override { return new FreeBuds(); }
};

void client_show_ecosystem(TechFactory* factory, const string& brand) {
    Phone* phone = factory->createPhone();
    Earphone* earphone = factory->createEarphone();

    cout << "--- " << brand << " Ecosystem Products ---" << endl;
    phone->show();
    earphone->show();
    cout << "---------------------------------" << endl;

    delete phone;
    delete earphone;
}

int main() {
    TechFactory* apple_store = new AppleFactory();
    client_show_ecosystem(apple_store, "Apple");
    delete apple_store;

    TechFactory* huawei_store = new HuaweiFactory();
    client_show_ecosystem(huawei_store, "Huawei");
    delete huawei_store;
    
    return 0;
}
```

### 4.3 效果分析

#### 4.3.1 优点
*   **保证产品族一致性：** 这是该模式的核心价值。客户端一旦选择了某个具体工厂（如`AppleFactory`），它创建的所有产品（`iPhone`, `AirPods`）都自然地属于同一个产品族，避免了品牌混搭的尴尬。
*   **隔离具体类：** 客户端代码只与抽象的接口（`TechFactory`, `Phone`, `Earphone`）打交道，完全看不到具体产品的实现。

#### 4.3.2 缺点
*   **扩展产品种类困难（违反开闭原则）：** 这又是它的**致命伤**。如果我们想给这个生态增加一个新产品，比如“智能手表(`SmartWatch`)”，那么：
    1.  必须修改**抽象工厂** `TechFactory` 的接口，增加 `virtual SmartWatch* createWatch() = 0;`。
    2.  所有**具体工厂**（`AppleFactory`, `HuaweiFactory`等）都必须跟着修改，实现这个新接口。
    这违背了开闭原则，改动成本巨大。

### 4.4 适用场景
*   当你的系统需要创建一系列相互关联的产品，并且要保证它们之间能够完美配合时。
*   系统不依赖于产品实例的创建、组合和表示的细节。
*   例子：跨平台的UI库。`WindowsFactory` 创建Windows风格的按钮和滚动条；`MacFactory` 创建macOS风格的按钮和滚动条。

---

## **5. 三种工厂模式对比总结**

| **模式**     | **一句话精髓**           | **优点**                       | **缺点**               | **解决的问题**       |
| :----------- | :----------------------- | :----------------------------- | :--------------------- | :------------------- |
| **简单工厂** | 一个全能管家，什么都管   | 简单，将创建与使用分离         | 违反开闭原则，不易扩展 | **“创建”的职责分离** |
| **工厂方法** | 各品牌开专卖店，各管各的 | 完美支持产品扩展，符合开闭原则 | 类数量爆炸             | **“扩展新产品”**     |
| **抽象工厂** | 品牌旗舰店，打造产品生态 | 保证产品族一致性               | 难以扩展产品种类       | **“创建产品族”**     |


---

## **6. 实际应用案例**

### 6.1 数据库访问层
这是抽象工厂最经典的案例。

*   **产品族：** `Connection`对象 + `Command`对象
*   **抽象工厂 `DBFactory`:** 定义 `createConnection()` 和 `createCommand()`。
*   **具体工厂 `SQLServerFactory`, `OracleFactory`:** 分别创建 `SqlConnection`/`SqlCommand` 和 `OracleConnection`/`OracleCommand`。

客户端选择一个工厂，就能获得一套能协同工作的数据库访问对象，无需关心底层是哪种数据库。

### 6.2 跨平台UI库
如Qt、wxWidgets等GUI框架的底层实现。

*   **产品族：** `Button` + `TextBox` + `Window`
*   **抽象工厂 `GUIFactory`:** 定义 `createButton()`, `createTextBox()` 等。
*   **具体工厂 `WindowsFactory`, `MacFactory`, `GTKFactory`:** 创建对应操作系统原生观感的UI控件。

程序在启动时根据当前操作系统选择一个具体工厂，整个应用的UI风格就能保持一致。

---

## **7. 总结**

今天我们沿着一条清晰的演进路线，从简单工厂、工厂方法，一路走到了抽象工厂。

> **核心 takeaway:** 工厂模式的本质是**封装对象创建过程，将“创建”与“使用”解耦**。

*   从 **简单工厂** 的集中管理，到 **工厂方法** 的分布式、可扩展创建，再到 **抽象工厂** 的产品族生态构建，每一种模式都是为了应对特定复杂度下的设计挑战。

学习设计模式，不是为了记忆僵化的UML图和代码模板，而是为了理解其背后**“权衡与取舍”**的智慧。没有最好的模式，只有最适合当前业务场景的模式。希望通过今天的学习，同学们能在未来的软件设计中，做出更优雅、更具扩展性的选择。

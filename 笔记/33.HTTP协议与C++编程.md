# 第30节课：HTTP协议与C++编程

## 课程目标
- 理解HTTP协议的基本概念和结构
- 学习如何使用命令行工具 `curl` 来测试HTTP请求
- 编写C++程序实现简单的HTTP请求
- 解析和处理HTTP响应

---

## 章节1：HTTP协议基础

### 1.1 什么是HTTPs协议？

HTTP（HyperText Transfer Protocol）是用于万维网上的分布式、协作式和超媒体信息系统的应用层协议。

### 1.2 HTTP请求结构
一个HTTP请求由下列部分组成：
- 请求行（Request Line）
- 请求头（Request Headers）
- 空行
- 可选的请求体（Request Body）

### 1.3 HTTP响应结构
一个HTTP响应由下列部分组成：
- 状态行（Status Line）
- 响应头（Response Headers）
- 空行
- 可选的响应体（Response Body）

---

## 章节2：使用curl命令行工具

### 2.1 GET请求示例
使用GET请求来获取网页内容。

```bash
curl -X GET http://www.example.com
```

### 2.2 POST请求示例

使用POST请求来提交表单数据。
```bash
curl -X POST http://www.example.com/form -d "key1=value1&key2=value2"
curl -X POST http://127.0.0.1:8080/form -d "key1=value1&key2=value2"
```

对应的服务端代码实现如下：
```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <map>
#include <thread>
#include <cstring> // for strerror

// 为跨平台编译处理头文件和类型
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib") // 链接 Winsock 库
    using socket_t = SOCKET;
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h> // for close
    #include <arpa/inet.h>
    using socket_t = int;
    const int INVALID_SOCKET = -1;
    const int SOCKET_ERROR = -1;
    #define closesocket close
#endif

const int PORT = 8080;
const int BUFFER_SIZE = 4096;

// 函数：解析 "key=value&key2=value2" 格式的字符串
std::map<std::string, std::string> parse_form_data(const std::string& body) {
    std::map<std::string, std::string> params;
    std::stringstream ss(body);
    std::string pair_str;

    while (std::getline(ss, pair_str, '&')) {
        size_t equal_pos = pair_str.find('=');
        if (equal_pos != std::string::npos) {
            std::string key = pair_str.substr(0, equal_pos);
            std::string value = pair_str.substr(equal_pos + 1);
            // 简单的URL解码（示例中不包含特殊字符，所以此步骤可简化）
            // 在实际应用中，需要一个完整的URL解码函数
            params[key] = value;
        }
    }
    return params;
}

// 函数：构建JSON响应体
std::string build_json_response(const std::map<std::string, std::string>& params) {
    std::string json = "{\n";
    json += "  \"status\": \"success\",\n";
    json += "  \"message\": \"Data received and parsed by Raw C++ Server\",\n";
    json += "  \"received_data\": {\n";
    for (auto it = params.cbegin(); it != params.cend(); ++it) {
        json += "    \"" + it->first + "\": \"" + it->second + "\"";
        if (std::next(it) != params.cend()) {
            json += ",";
        }
        json += "\n";
    }
    json += "  }\n";
    json += "}";
    return json;
}


// 核心函数：处理单个客户端连接
void handle_client(socket_t client_socket) {
    char buffer[BUFFER_SIZE] = {0};
    
    // 1. 从客户端接收数据
    int bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
    if (bytes_received <= 0) {
        std::cerr << "Failed to receive data or connection closed." << std::endl;
        closesocket(client_socket);
        return;
    }

    std::string request(buffer, bytes_received);
    std::cout << "--- New Request Received ---\n" << request << "\n--------------------------\n";

    // 2. 解析HTTP请求
    std::string method, path, http_version, body;
    std::map<std::string, std::string> headers;
    size_t content_length = 0;

    std::istringstream request_stream(request);
    request_stream >> method >> path >> http_version;
    
    // 读取头部
    std::string header_line;
    // 跳过请求行后的换行符
    std::getline(request_stream, header_line); 
    while (std::getline(request_stream, header_line) && header_line != "\r") {
        size_t colon_pos = header_line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = header_line.substr(0, colon_pos);
            std::string value = header_line.substr(colon_pos + 2); // 跳过 ": "
            value.pop_back(); // 移除末尾的 \r
            headers[key] = value;
            if (key == "Content-Length") {
                content_length = std::stoi(value);
            }
        }
    }
    
    // 3. 检查请求是否符合要求并处理
    if (method == "POST" && path == "/form") {
        // 请求体在 `\r\n\r\n` 之后
        size_t body_start = request.find("\r\n\r\n");
        if (body_start != std::string::npos) {
            body = request.substr(body_start + 4, content_length);
            std::cout << "Request Body: " << body << std::endl;
        }

        // 解析表单数据
        auto params = parse_form_data(body);

        // 构建响应
        std::string response_body = build_json_response(params);
        std::stringstream response_stream;
        response_stream << "HTTP/1.1 200 OK\r\n";
        response_stream << "Content-Type: application/json\r\n";
        response_stream << "Content-Length: " << response_body.length() << "\r\n";
        response_stream << "Connection: close\r\n";
        response_stream << "\r\n"; // 头部和内容的分隔符
        response_stream << response_body;

        std::string response_str = response_stream.str();
        send(client_socket, response_str.c_str(), response_str.length(), 0);
        std::cout << "Sent 200 OK response.\n\n";

    } else {
        // 对于其他请求，返回 404 Not Found
        const char* response_404 =
            "HTTP/1.1 404 Not Found\r\n"
            "Content-Type: text/plain\r\n"
            "Content-Length: 13\r\n"
            "Connection: close\r\n"
            "\r\n"
            "Not Found";
        send(client_socket, response_404, strlen(response_404), 0);
        std::cout << "Sent 404 Not Found response for path: " << path << "\n\n";
    }

    // 4. 关闭客户端套接字
    closesocket(client_socket);
}


int main() {
    #ifdef _WIN32
        WSADATA wsaData;
        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
            std::cerr << "WSAStartup failed." << std::endl;
            return 1;
        }
    #endif

    // 创建监听套接字
    socket_t listen_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_socket == INVALID_SOCKET) {
        std::cerr << "Failed to create socket." << std::endl;
        return 1;
    }

    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY; // 监听所有可用网络接口
    server_addr.sin_port = htons(PORT);

    // 绑定套接字到端口
    if (bind(listen_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
        std::cerr << "Bind failed." << std::endl;
        closesocket(listen_socket);
        return 1;
    }

    // 开始监听
    if (listen(listen_socket, SOMAXCONN) == SOCKET_ERROR) {
        std::cerr << "Listen failed." << std::endl;
        closesocket(listen_socket);
        return 1;
    }

    std::cout << "C++ Raw Socket Server listening on port " << PORT << std::endl;
    std::cout << "Waiting for connections..." << std::endl;

    while (true) {
        sockaddr_in client_addr;
        int client_addr_size = sizeof(client_addr);
        
        // 接受一个客户端连接（此调用会阻塞，直到有连接进来）
        socket_t client_socket = accept(listen_socket, (struct sockaddr*)&client_addr, (socklen_t*)&client_addr_size);
        
        if (client_socket == INVALID_SOCKET) {
            std::cerr << "Accept failed." << std::endl;
            continue; // 继续等待下一个连接
        }
        
        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        std::cout << "Accepted connection from " << client_ip << ":" << ntohs(client_addr.sin_port) << std::endl;

        // 为每个客户端创建一个新线程来处理（简单并发模型）
        // 注意：在更复杂的应用中，线程池是更好的选择
        std::thread client_thread(handle_client, client_socket);
        client_thread.detach(); // 分离线程，让它独立运行
    }

    // 清理
    closesocket(listen_socket);
    #ifdef _WIN32
        WSACleanup();
    #endif

    return 0;
}
```



> [!NOTE]
>如何编译和运行
>在 Linux / macOS 上
>打开终端，使用 g++ 编译器：
>```bash
># -pthread 是链接线程库所必需的
>g++ raw_server.cpp -o raw_server -pthread
>```

### 2.3 设置自定义头信息

添加自定义头信息以发送不同类型的请求。

```bash
curl -X GET http://www.example.com -H "Authorization: Bearer <token>"
curl -X GET http://127.0.0.1:8080 -H "Authorization: Bearer THIS_IS_A_VERY_SECRET_TOKEN_12345"
```
对应的服务端示例代码如下：
```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <map>
#include <thread>
#include <cstring>   // for strerror, strlen
#include <algorithm> // for std::transform

// 为跨平台编译处理头文件和类型
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
    using socket_t = SOCKET;
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    using socket_t = int;
    const int INVALID_SOCKET = -1;
    const int SOCKET_ERROR = -1;
    #define closesocket close
#endif

const int PORT = 8080;
const int BUFFER_SIZE = 4096;

// 为了教学目的，我们将正确的 Token 硬编码在这里
const std::string SECRET_TOKEN = "THIS_IS_A_VERY_SECRET_TOKEN_12345";

// 辅助函数：发送HTTP响应，避免代码重复
void send_response(socket_t client_socket, const std::string& status_line, const std::string& content_type, const std::string& body, const std::vector<std::string>& extra_headers = {}) {
    std::stringstream response;
    response << status_line << "\r\n";
    response << "Content-Type: " << content_type << "\r\n";
    response << "Content-Length: " << body.length() << "\r\n";
    for (const auto& header : extra_headers) {
        response << header << "\r\n";
    }
    response << "Connection: close\r\n";
    response << "\r\n"; // 头部和正文的分隔符
    response << body;

    std::string response_str = response.str();
    send(client_socket, response_str.c_str(), response_str.length(), 0);
}


// 核心函数：处理单个客户端连接
void handle_client(socket_t client_socket) {
    char buffer[BUFFER_SIZE] = {0};
    
    // 1. 从客户端接收数据
    int bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
    if (bytes_received <= 0) {
        std::cerr << "Failed to receive data or connection closed." << std::endl;
        closesocket(client_socket);
        return;
    }

    std::string request(buffer, bytes_received);
    std::cout << "--- New Request Received ---\n" << request << "\n--------------------------\n";

    // 2. 解析HTTP请求
    std::string method, path;
    std::map<std::string, std::string> headers;

    std::istringstream request_stream(request);
    request_stream >> method >> path; // 提取方法和路径
    
    // 读取头部
    std::string header_line;
    std::getline(request_stream, header_line); // 跳过请求行剩余部分
    while (std::getline(request_stream, header_line) && !header_line.empty() && header_line[0] != '\r') {
        size_t colon_pos = header_line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = header_line.substr(0, colon_pos);
            // 为实现大小写不敏感，将 key 转为小写
            std::transform(key.begin(), key.end(), key.begin(), ::tolower);
            // 跳过冒号和空格
            std::string value = header_line.substr(colon_pos + 2);
            // 移除末尾的 \r
            if (!value.empty() && value.back() == '\r') {
                value.pop_back();
            }
            headers[key] = value;
        }
    }

    // 3. 业务逻辑：检查GET / 和 Authorization 头部
    if (method == "GET" && path == "/") {
        auto auth_it = headers.find("authorization");

        if (auth_it == headers.end()) {
            // 情况1: 未找到 Authorization 头部 -> 401 Unauthorized
            std::cout << "Auth Status: Missing Authorization header." << std::endl;
            std::string body = "{\"error\":\"Authorization header is required\"}";
            std::vector<std::string> extra_headers = {"WWW-Authenticate: Bearer realm=\"My Protected API\""};
            send_response(client_socket, "HTTP/1.1 401 Unauthorized", "application/json", body, extra_headers);
            std::cout << "Sent 401 Unauthorized response.\n\n";

        } else {
            std::string auth_header = auth_it->second;
            std::string bearer_prefix = "Bearer ";
            // 检查头部格式是否为 "Bearer <token>"
            if (auth_header.rfind(bearer_prefix, 0) == 0) {
                std::string received_token = auth_header.substr(bearer_prefix.length());
                if (received_token == SECRET_TOKEN) {
                    // 情况2: Token正确 -> 200 OK
                    std::cout << "Auth Status: Success! Token is valid." << std::endl;
                    std::string body = "{\"status\":\"success\",\"message\":\"Welcome, you are authenticated!\"}";
                    send_response(client_socket, "HTTP/1.1 200 OK", "application/json", body);
                    std::cout << "Sent 200 OK response.\n\n";
                } else {
                    // 情况3: Token错误 -> 403 Forbidden
                    std::cout << "Auth Status: Failure! Invalid token." << std::endl;
                    std::string body = "{\"error\":\"Forbidden: Invalid token provided\"}";
                    send_response(client_socket, "HTTP/1.1 403 Forbidden", "application/json", body);
                    std::cout << "Sent 403 Forbidden response.\n\n";
                }
            } else {
                // 情况4: Authorization 头部格式错误 -> 400 Bad Request
                std::cout << "Auth Status: Failure! Invalid auth header format." << std::endl;
                std::string body = "{\"error\":\"Bad Request: Authorization header must be of type Bearer\"}";
                send_response(client_socket, "HTTP/1.1 400 Bad Request", "application/json", body);
                std::cout << "Sent 400 Bad Request response.\n\n";
            }
        }
    } else {
        // 对于其他所有请求，返回 404 Not Found
        std::cout << "Request to unknown path: " << path << std::endl;
        std::string body = "Not Found";
        send_response(client_socket, "HTTP/1.1 404 Not Found", "text/plain", body);
        std::cout << "Sent 404 Not Found response.\n\n";
    }

    closesocket(client_socket);
}

// 主函数，与上一个例子基本相同
int main() {
    #ifdef _WIN32
        WSADATA wsaData;
        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
            std::cerr << "WSAStartup failed." << std::endl; return 1;
        }
    #endif

    socket_t listen_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_socket == INVALID_SOCKET) {
        std::cerr << "Failed to create socket." << std::endl; return 1;
    }

    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(listen_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
        std::cerr << "Bind failed." << std::endl; closesocket(listen_socket); return 1;
    }

    if (listen(listen_socket, SOMAXCONN) == SOCKET_ERROR) {
        std::cerr << "Listen failed." << std::endl; closesocket(listen_socket); return 1;
    }

    std::cout << "C++ Auth Server listening on port " << PORT << std::endl;
    std::cout << "Protected endpoint is at GET http://localhost:8080/" << std::endl;
    std::cout << "Expected Token: Bearer " << SECRET_TOKEN << std::endl;
    std::cout << "Waiting for connections..." << std::endl;

    while (true) {
        socket_t client_socket = accept(listen_socket, NULL, NULL);
        if (client_socket == INVALID_SOCKET) {
            std::cerr << "Accept failed." << std::endl; continue;
        }
        std::thread(handle_client, client_socket).detach();
    }

    closesocket(listen_socket);
    #ifdef _WIN32
        WSACleanup();
    #endif

    return 0;
}
```
### 2.4 下载文件

将服务返回的数据保存到文件中。

```bash
curl -O http://www.example.com/file.zip
curl -O http://127.0.0.1:8080/file.zip
```
对应的服务端代码示例如下：
```cpp
// file_server.cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <thread>
#include <fstream>
#include <cstring>
#include <cerrno>
#include <cstdlib>

// --- Platform-specific socket headers --------------------
#ifdef _WIN32
    #define _WINSOCK_DEPRECATED_NO_WARNINGS
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
    using socket_t = SOCKET;
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    using socket_t = int;
    constexpr int INVALID_SOCKET = -1;
    constexpr int SOCKET_ERROR   = -1;
    #define closesocket close
#endif
// --------------------------------------------------------

constexpr int PORT         = 8080;
constexpr int BUFFER_SIZE  = 4096;
const std::string FILE_TO_SERVE = "file.zip";

unsigned char DUMMY_ZIP_DATA[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x78,
  0xe6, 0x5a, 0xa8, 0x4b, 0x1f, 0x07, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x1c, 0x00, 0x6c, 0x6f, 0x76, 0x65, 0x2e, 0x74,
  0x78, 0x74, 0x55, 0x54, 0x09, 0x00, 0x03, 0xf8, 0x1e, 0x6a, 0x68, 0xf9,
  0x1e, 0x6a, 0x68, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00,
  0x00, 0x04, 0x14, 0x00, 0x00, 0x00, 0x49, 0x20, 0x6c, 0x6f, 0x76, 0x65,
  0x20, 0x43, 0x2b, 0x2b, 0x0a, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x78, 0xe6, 0x5a, 0xa8, 0x4b, 0x1f,
  0x07, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x08, 0x00, 0x18,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00,
  0x00, 0x00, 0x00, 0x6c, 0x6f, 0x76, 0x65, 0x2e, 0x74, 0x78, 0x74, 0x55,
  0x54, 0x05, 0x00, 0x03, 0xf8, 0x1e, 0x6a, 0x68, 0x75, 0x78, 0x0b, 0x00,
  0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x14, 0x00, 0x00, 0x00, 0x50,
  0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x4e,
  0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00
};
/* ------------------------------------------------------ */

void create_dummy_file()
{
    std::cout << "Creating dummy file '" << FILE_TO_SERVE
              << "' (" << sizeof(DUMMY_ZIP_DATA) << " bytes)...\n";

    std::ofstream ofs(FILE_TO_SERVE, std::ios::binary);
    if (!ofs) {
        std::cerr << "Cannot create " << FILE_TO_SERVE << "\n";
        std::exit(EXIT_FAILURE);
    }
    ofs.write(reinterpret_cast<const char*>(DUMMY_ZIP_DATA),
              sizeof(DUMMY_ZIP_DATA));
}

void handle_client(socket_t client_socket)
{
    char buffer[BUFFER_SIZE] = {0};

    int recv_len = ::recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
    if (recv_len <= 0) {
        std::cerr << "recv() failed or connection closed prematurely.\n";
        closesocket(client_socket);
        return;
    }
    buffer[recv_len] = '\0';                        // 保证字符串结束
    std::string request(buffer);

    // 打印请求头
    std::cout << "\n----- New Request -----\n"
              << request.substr(0, request.find("\r\n\r\n")) << "\n----------------------\n";

    std::istringstream iss(request);
    std::string method, path;
    iss >> method >> path;

    if (method == "GET" && path == "/" + FILE_TO_SERVE) {
        std::ifstream file(FILE_TO_SERVE, std::ios::binary | std::ios::ate);
        if (!file) {
            const char* msg = "HTTP/1.1 500 Internal Server Error\r\n"
                              "Content-Length: 21\r\n\r\nCould not open file.";
            ::send(client_socket, msg, std::strlen(msg), 0);
        } else {
            std::streamsize file_size = file.tellg();
            if (file_size < 0) file_size = 0;
            file.seekg(0, std::ios::beg);
            std::vector<char> file_buf(static_cast<size_t>(file_size));
            file.read(file_buf.data(), file_size);

            std::ostringstream hdr;
            hdr << "HTTP/1.1 200 OK\r\n"
                << "Content-Type: application/zip\r\n"
                << "Content-Length: " << file_size << "\r\n"
                << "Content-Disposition: attachment; filename=\""
                << FILE_TO_SERVE << "\"\r\n"
                << "Connection: close\r\n\r\n";
            std::string hdr_str = hdr.str();

            ::send(client_socket, hdr_str.c_str(), static_cast<int>(hdr_str.size()), 0);
            ::send(client_socket, file_buf.data(), static_cast<int>(file_buf.size()), 0);
            std::cout << "Sent " << file_size << " bytes of '" << FILE_TO_SERVE << "'.\n";
        }
    } else {
        const char* res404 = "HTTP/1.1 404 Not Found\r\nConnection: close\r\n\r\nNot Found.";
        ::send(client_socket, res404, std::strlen(res404), 0);
        std::cout << "404 for path: " << path << "\n";
    }

#ifdef _WIN32
    ::shutdown(client_socket, SD_SEND);
#else
    ::shutdown(client_socket, SHUT_WR);
#endif
    closesocket(client_socket);
}

int main()
{
#ifdef _WIN32
    WSADATA wsa;
    if (WSAStartup(MAKEWORD(2,2), &wsa) != 0) {
        std::cerr << "WSAStartup failed\n";
        return EXIT_FAILURE;
    }
#endif

    create_dummy_file();

    socket_t listen_socket = ::socket(AF_INET, SOCK_STREAM, 0);
    if (listen_socket == INVALID_SOCKET) {
#ifdef _WIN32
        std::cerr << "socket() failed: " << WSAGetLastError() << "\n";
#else
        std::cerr << "socket() failed: " << std::strerror(errno) << "\n";
#endif
        return EXIT_FAILURE;
    }

    int opt = 1;
#ifdef _WIN32
    ::setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR,
                 reinterpret_cast<const char*>(&opt), sizeof(opt));
#else
    ::setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR,
                 &opt, sizeof(opt));
#endif

    sockaddr_in server_addr;
    std::memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family      = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port        = htons(PORT);

    if (::bind(listen_socket,
               reinterpret_cast<sockaddr*>(&server_addr),
               sizeof(server_addr)) == SOCKET_ERROR) {
#ifdef _WIN32
        std::cerr << "bind() failed: " << WSAGetLastError() << "\n";
#else
        std::cerr << "bind() failed: " << std::strerror(errno) << "\n";
#endif
        return EXIT_FAILURE;
    }

    ::listen(listen_socket, SOMAXCONN);
    std::cout << "File server running on http://localhost:" << PORT
              << "/" << FILE_TO_SERVE << "\n";

    while (true) {
        socket_t client = ::accept(listen_socket, nullptr, nullptr);
        if (client == INVALID_SOCKET) continue;

        // 用 lambda 把 socket 交给线程
        std::thread([client]() { handle_client(client); }).detach();
    }

    closesocket(listen_socket);
#ifdef _WIN32
    WSACleanup();
#endif
    return 0;
}

```

------

## 章节3：使用C++进行HTTP请求

### 3.1 设置C++开发环境

确保安装了支持C++17或更高标准的编译器，并安装了curl库来处理HTTP请求。

- **安装libcurl：**

   

  **Ubuntu:**

  

  ```bash
  sudo apt-get install libcurl4-openssl-dev
  ```


### 3.2 发送GET请求

使用libcurl在C++中发送GET请求。

客户端：

```cpp
#include <iostream>
#include <curl/curl.h>

static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp)
{
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

int main()
{
    CURL* curl = nullptr;
    CURLcode res;
    std::string readBuffer;

    curl = curl_easy_init();
    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, "http://127.0.0.1:8080/");
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
        res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);

        if(res != CURLE_OK)
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
        else
            std::cout << readBuffer << std::endl;
    }

    return 0;
}
```

服务端代码：
```cpp
// server_manual.cpp

#include <iostream>
#include <string>
#include <sstream> // 用于构建响应字符串
#include <vector>

// --- 平台特定的头文件和定义 ---
#ifdef _WIN32
    #define _WIN32_WINNT 0x0A00 // 使用较新的 Windows API
    #include <winsock2.h>
    #include <ws2tcpip.h>
    // 链接 Winsock 库
    #pragma comment(lib, "ws2_32.lib")
#else // 对于 Linux, macOS 等 POSIX 系统
    #include <sys/socket.h> // 套接字函数
    #include <netinet/in.h> // sockaddr_in 结构
    #include <unistd.h>     // close() 函数
    #include <arpa/inet.h>  // inet_addr
    // 为了统一，定义一些 Windows 特有的类型/函数
    using SOCKET = int;
    const int INVALID_SOCKET = -1;
    const int SOCKET_ERROR = -1;
    #define closesocket(s) close(s)
#endif

const int PORT = 8080;
const int BUFFER_SIZE = 4096;

void print_error(const char* message) {
#ifdef _WIN32
    std::cerr << message << " | Winsock Error: " << WSAGetLastError() << std::endl;
#else
    perror(message);
#endif
}

int main() {
    // --- 1. 初始化套接字库 (仅 Windows 需要) ---
#ifdef _WIN32
    WSADATA wsaData;
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0) {
        std::cerr << "WSAStartup failed: " << result << std::endl;
        return 1;
    }
    std::cout << "Winsock initialized." << std::endl;
#endif

    // --- 2. 创建监听套接字 ---
    // AF_INET: 使用 IPv4 地址族
    // SOCK_STREAM: 使用面向连接的 TCP 协议
    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (listenSocket == INVALID_SOCKET) {
        print_error("Failed to create socket");
#ifdef _WIN32
        WSACleanup();
#endif
        return 1;
    }
    std::cout << "Listening socket created." << std::endl;
    
    // (可选，但推荐) 设置套接字选项，允许地址重用
    int opt = 1;
    setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));

    // --- 3. 绑定套接字到 IP 地址和端口 ---
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT); // htons: Host TO Network Short，转换端口号为网络字节序
    serverAddr.sin_addr.s_addr = INADDR_ANY; // 监听所有可用的网络接口 (0.0.0.0)

    if (bind(listenSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        print_error("Bind failed");
        closesocket(listenSocket);
#ifdef _WIN32
        WSACleanup();
#endif
        return 1;
    }
    std::cout << "Socket bound to address 0.0.0.0:" << PORT << std::endl;

    // --- 4. 开始监听连接请求 ---
    // 第二个参数是 "backlog"，即等待处理的连接队列大小
    if (listen(listenSocket, SOMAXCONN) == SOCKET_ERROR) {
        print_error("Listen failed");
        closesocket(listenSocket);
#ifdef _WIN32
        WSACleanup();
#endif
        return 1;
    }
    std::cout << "Server is listening..." << std::endl;

    // --- 5. 循环接受客户端连接 ---
    while (true) {
        sockaddr_in clientAddr;
        socklen_t clientAddrSize = sizeof(clientAddr);

        // accept() 是一个阻塞函数，它会等待直到有客户端连接进来
        // 它会返回一个新的套接字，用于与这个特定客户端通信
        SOCKET clientSocket = accept(listenSocket, (sockaddr*)&clientAddr, &clientAddrSize);

        if (clientSocket == INVALID_SOCKET) {
            print_error("Accept failed");
            continue; // 继续等待下一个连接
        }
        
        char clientIp[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &clientAddr.sin_addr, clientIp, INET_ADDRSTRLEN);
        std::cout << "\n--- Client connected from " << clientIp << ":" << ntohs(clientAddr.sin_port) << " ---" << std::endl;

        // --- 6. 接收客户端的 HTTP 请求 ---
        std::vector<char> buffer(BUFFER_SIZE);
        int bytesReceived = recv(clientSocket, buffer.data(), buffer.size(), 0);

        if (bytesReceived > 0) {
            std::cout << "Received request:" << std::endl;
            std::cout.write(buffer.data(), bytesReceived);
            std::cout << "--------------------" << std::endl;

            // --- 7. 构造并发送 HTTP 响应 ---
            std::string response_body = "Hello from the pure C++ server!";
            
            // 使用 stringstream 方便地构建响应
            std::stringstream response_stream;
            response_stream << "HTTP/1.1 200 OK\r\n";
            response_stream << "Content-Type: text/plain\r\n";
            response_stream << "Content-Length: " << response_body.length() << "\r\n";
            response_stream << "Connection: close\r\n"; // 告知客户端我们会关闭连接
            response_stream << "\r\n"; // HTTP 头和主体之间的空行
            response_stream << response_body;

            std::string http_response = response_stream.str();
            
            // 发送响应
            int bytesSent = send(clientSocket, http_response.c_str(), http_response.length(), 0);
            if (bytesSent == SOCKET_ERROR) {
                print_error("Send failed");
            } else {
                 std::cout << "Response sent (" << bytesSent << " bytes)." << std::endl;
            }

        } else if (bytesReceived == 0) {
            std::cout << "Client disconnected gracefully." << std::endl;
        } else {
            print_error("Recv failed");
        }

        // --- 8. 关闭与该客户端的连接 ---
        closesocket(clientSocket);
        std::cout << "Client socket closed." << std::endl;
    }

    // --- 9. 清理 (虽然在无限循环中，但这才是完整的写法) ---
    closesocket(listenSocket);
#ifdef _WIN32
    WSACleanup();
#endif

    return 0;
}
```

### 3.3 发送POST请求

使用libcurl在C++中发送POST请求。



```cpp
#include <iostream>
#include <curl/curl.h>

int main()
{
    CURL* curl;
    CURLcode res;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, "http://www.example.com/form");
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, "key1=value1&key2=value2");

        res = curl_easy_perform(curl);
        if(res != CURLE_OK)
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;

        curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
    return 0;
}
```

### 3.4 添加HTTP头信息

在C++中设置HTTP请求的头信息。



```cpp
#include <iostream>
#include <curl/curl.h>

int main()
{
    CURL* curl;
    CURLcode res;

    struct curl_slist* headers = NULL;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    headers = curl_slist_append(headers, "Authorization: Bearer ABC123XYZ");

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, "http://127.0.0.1:8080/api");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        res = curl_easy_perform(curl);
        if(res != CURLE_OK)
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;

        curl_easy_cleanup(curl);
    }

    curl_slist_free_all(headers);
    curl_global_cleanup();
    return 0;
}
```

服务端代码如下：
```cpp
// server_interactive.cpp

#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <map>
#include <algorithm> // For std::transform
#include <cctype>    // For tolower

// --- 平台特定的网络代码 (与上一个例子相同) ---
#ifdef _WIN32
    #define _WIN32_WINNT 0x0A00
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    using SOCKET = int;
    const int INVALID_SOCKET = -1;
    const int SOCKET_ERROR = -1;
    #define closesocket(s) close(s)
#endif

const int PORT = 8080;
const int BUFFER_SIZE = 4096;

void print_error(const char* message) {
#ifdef _WIN32
    std::cerr << message << " | Winsock Error: " << WSAGetLastError() << std::endl;
#else
    perror(message);
#endif
}

// 辅助函数：将字符串转为小写，以便不区分大小写地比较头域名
std::string to_lower(std::string s) {
    std::transform(s.begin(), s.end(), s.begin(),
                   [](unsigned char c){ return std::tolower(c); });
    return s;
}

// --- 新增：解析HTTP请求的函数 ---
void parse_request(const std::string& raw_request, std::string& method, std::string& path, std::map<std::string, std::string>& headers) {
    std::stringstream request_stream(raw_request);
    std::string line;

    // 1. 解析请求行 (e.g., "GET /api HTTP/1.1")
    if (std::getline(request_stream, line) && !line.empty()) {
        std::stringstream line_stream(line);
        line_stream >> method >> path;
    }

    // 2. 解析请求头
    while (std::getline(request_stream, line) && line != "\r") {
        auto colon_pos = line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = line.substr(0, colon_pos);
            std::string value = line.substr(colon_pos + 1);

            // 清理 value 的前后空格
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t\r") + 1);

            // 存储头信息，键转为小写
            headers[to_lower(key)] = value;
        }
    }
}

// --- 新增：构造并发送HTTP响应的函数 ---
void send_response(SOCKET client_socket, int status_code, const std::string& status_text, const std::string& content_type, const std::string& body) {
    std::stringstream response_stream;
    response_stream << "HTTP/1.1 " << status_code << " " << status_text << "\r\n";
    response_stream << "Content-Type: " << content_type << "\r\n";
    response_stream << "Content-Length: " << body.length() << "\r\n";
    response_stream << "Connection: close\r\n";
    response_stream << "\r\n";
    response_stream << body;

    std::string http_response = response_stream.str();
    send(client_socket, http_response.c_str(), http_response.length(), 0);
}


int main() {
    // --- 1. 初始化套接字库 (仅 Windows) ---
#ifdef _WIN32
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        std::cerr << "WSAStartup failed." << std::endl; return 1;
    }
#endif

    // --- 2. 创建监听套接字 ---
    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (listenSocket == INVALID_SOCKET) {
        print_error("Failed to create socket"); return 1;
    }
    int opt = 1;
    setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));

    // --- 3. 绑定IP和端口 ---
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    if (bind(listenSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        print_error("Bind failed");
        closesocket(listenSocket); return 1;
    }

    // --- 4. 开始监听 ---
    if (listen(listenSocket, SOMAXCONN) == SOCKET_ERROR) {
        print_error("Listen failed");
        closesocket(listenSocket); return 1;
    }
    std::cout << "Server is listening on port " << PORT << "..." << std::endl;

    // --- 5. 循环接受连接并处理 ---
    while (true) {
        SOCKET clientSocket = accept(listenSocket, NULL, NULL);
        if (clientSocket == INVALID_SOCKET) {
            print_error("Accept failed");
            continue;
        }

        std::cout << "\n--- Client connected ---" << std::endl;

        // 接收数据
        std::vector<char> buffer(BUFFER_SIZE);
        int bytesReceived = recv(clientSocket, buffer.data(), buffer.size() - 1, 0);
        
        if (bytesReceived > 0) {
            buffer[bytesReceived] = '\0'; // 确保字符串结束
            std::string raw_request(buffer.data());
            
            std::cout << "Raw Request Received:\n" << raw_request << std::endl;
            
            // 解析请求
            std::string method, path;
            std::map<std::string, std::string> headers;
            parse_request(raw_request, method, path, headers);

            // 打印解析结果，用于教学
            std::cout << "--- Parsed Info ---" << std::endl;
            std::cout << "Method: " << method << std::endl;
            std::cout << "Path: " << path << std::endl;
            for (const auto& pair : headers) {
                std::cout << "Header: " << pair.first << " => " << pair.second << std::endl;
            }
            std::cout << "--------------------" << std::endl;


            // ---- 核心业务逻辑 ----
            if (path == "/api") {
                // 检查 Authorization 头部
                if (headers.count("authorization") && headers["authorization"] == "Bearer ABC123XYZ") {
                    // 认证成功
                    std::cout << "Authorization SUCCESSFUL." << std::endl;
                    std::string body = "{\"status\":\"success\", \"message\":\"Authentication successful! Welcome.\"}";
                    send_response(clientSocket, 200, "OK", "application/json", body);
                } else {
                    // 认证失败
                    std::cout << "Authorization FAILED." << std::endl;
                    std::string body = "{\"status\":\"error\", \"message\":\"Invalid or missing Authorization token.\"}";
                    send_response(clientSocket, 401, "Unauthorized", "application/json", body);
                }
            } else {
                // 路径不匹配
                std::cout << "Path not found." << std::endl;
                std::string body = "Resource not found on this server.";
                send_response(clientSocket, 404, "Not Found", "text/plain", body);
            }
        }

        closesocket(clientSocket);
        std::cout << "Client socket closed." << std::endl;
    }

    closesocket(listenSocket);
#ifdef _WIN32
    WSACleanup();
#endif
    return 0;
}
```



------

## HTTP 服务器原理讲解

实现一个简单的 HTTP 服务器仅使用 C++ 标准库，对于基本的 GET 和 POST 请求的支持，可以通过 UNIX 系统的套接字 API 来实现。在这个实现演示中，一个最小功能的 HTTP 服务器将解析简单的 HTTP 请求并提供响应。

这是一个使用 C++ 和标准 POSIX Socket API 实现简单 HTTP 服务器的完整示例：

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <thread>
#include <vector>

const int PORT = 8080;

// Function for handling client connections
void handle_client(int client_socket) {
    char buffer[1024] = {0};
    int bytes_read = read(client_socket, buffer, 1024);
    if (bytes_read < 0) {
        std::cerr << "Failed to read from socket\n";
        close(client_socket);
        return;
    }

    std::string request(buffer, bytes_read);
    std::istringstream request_stream(request);
    std::string method;
    std::string path;
    std::string version;

    request_stream >> method >> path >> version;

    std::string response;

    if (method == "GET") {
        if (path == "/") {
            response = 
                "HTTP/1.1 200 OK\r\n"
                "Content-Type: text/plain\r\n"
                "Content-Length: 13\r\n"
                "\r\n"
                "Hello, World!";
        } else {
            response = 
                "HTTP/1.1 404 Not Found\r\n"
                "Content-Type: text/plain\r\n"
                "Content-Length: 9\r\n"
                "\r\n"
                "Not Found";
        }
    } else if (method == "POST") {
        std::string header;
        std::string request_body;
        while (std::getline(request_stream, header) && header != "\r") {
            // Process headers if needed
        }

        if (request_stream.rdbuf()->in_avail()) {
            request_body.assign((std::istreambuf_iterator<char>(request_stream)), std::istreambuf_iterator<char>());
        }

        response = 
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/plain\r\n"
            "Content-Length: " + std::to_string(request_body.length()) + "\r\n"
            "\r\n" + request_body;
    } else {
        response = 
            "HTTP/1.1 405 Method Not Allowed\r\n"
            "Content-Type: text/plain\r\n"
            "Content-Length: 18\r\n"
            "\r\n"
            "Method Not Allowed";
    }

    send(client_socket, response.c_str(), response.length(), 0);
    close(client_socket);
}

int main() {
    int server_fd, client_socket;
    sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    // Create socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        std::cerr << "Socket failed\n";
        exit(EXIT_FAILURE);
    }

    // Forcefully attaching socket to the port 8080
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        std::cerr << "setsockopt failed\n";
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind the socket to the network address and port
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        std::cerr << "Bind failed\n";
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Start listening for incoming connections
    if (listen(server_fd, 3) < 0) {
        std::cerr << "Listen failed\n";
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    std::cout << "Listening on port " << PORT << "...\n";

    while (true) {
        if ((client_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
            std::cerr << "Accept failed\n";
            continue;
        }

        // Handle each client in a separate thread
        std::thread(handle_client, client_socket).detach();
    }

    return 0;
}
```

### 服务器说明

1. **套接字创建**：
   - 使用 `socket()` 创建一个 TCP socket。
   
2. **设置选项**：
   - 使用 `setsockopt()` 设置套接字选项，以便在服务器关闭后立即重用端口。

3. **绑定和监听**：
   - 将服务器绑定到本地的指定端口 `8080`。
   - `listen()` 方法监听传入的连接。

4. **接受连接**：
   - `accept()` 用于接受进入的连接，并为每个连接生成一个线程通过 `std::thread` 调用 `handle_client()`。

5. **请求处理**：
   - 通过 `read()` 从套接字读取客户端请求。
   - 解析 `GET` 和 `POST` 请求，返回相应的响应。
   - 使用 `send()` 发送 HTTP 响应到客户端。

### 测试

编译并运行你的服务器后，可以使用 `curl` 来测试它：

- **GET 请求**：
  ```bash
  curl -X GET http://localhost:8080/
  ```

- **POST 请求**：
  ```bash
  curl -X POST http://localhost:8080/ -d "test data"
  
  # 上传图片
  curl -X POST \
       -H "Content-Type: application/octet-stream" \
       --upload-file qmsht.jpeg \
       http://127.0.0.1:8080/upload
  ```

该服务器只是一个最小化的演示，能够处理基本的 GET 和 POST 请求，并返回有限的响应。在生产中应使用更健壮和成熟的解决方案来处理HTTP服务器需求，包括错误处理、并发管理以及HTTP协议的完整实现。



## 现代 BS 架构代码

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <fstream>
#include <thread>
#include <map>
#include <cstring>
#include <algorithm> 

// --- 为跨平台编译处理套接字头文件 ---
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
    using socket_t = SOCKET;
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    using socket_t = int;
    const int INVALID_SOCKET = -1;
    const int SOCKET_ERROR = -1;
    #define closesocket close
#endif

const int PORT = 8080;
const int BUFFER_SIZE = 8192; 

const std::string htmlPageWithJs = R"HTML_CONTENT(
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Stream Upload (C++)</title>
    <style>
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #e0f7fa; }
        .container { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center; }
        h1 { color: #00796b; }
        input[type="file"] { border: 1px solid #ccc; padding: 10px; border-radius: 4px; display: block; margin: 1rem auto; }
        button { background-color: #009688; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; }
        button:hover { background-color: #00796b; }
        #status { margin-top: 1rem; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Upload File as Binary Stream</h1>
        <input type="file" id="fileInput" required>
        <button onclick="uploadFile()">Upload File</button>
        <div id="status"></div>
    </div>

    <script>
        function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const statusDiv = document.getElementById('status');

            if (fileInput.files.length === 0) {
                statusDiv.textContent = 'Please select a file first!';
                statusDiv.style.color = 'red';
                return;
            }

            const file = fileInput.files[0];
            statusDiv.textContent = 'Uploading...';
            statusDiv.style.color = 'black';

            // 使用 fetch API 发送二进制流
            fetch('/upload', {
                method: 'POST',
                headers: {
                    'X-File-Name': encodeURIComponent(file.name),
                    'Content-Type': 'application/octet-stream'
                },
                body: file
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server responded with ${response.status}`);
                }
                return response.text();
            })
            .then(text => {
                statusDiv.textContent = 'Success: ' + text;
                statusDiv.style.color = 'green';
            })
            .catch(error => {
                statusDiv.textContent = 'Error: ' + error.message;
                statusDiv.style.color = 'red';
            });
        }
    </script>
</body>
</html>
)HTML_CONTENT";

void send_response(socket_t sock, const std::string& status, const std::string& content_type, const std::string& body) {
    std::stringstream ss;
    ss << "HTTP/1.1 " << status << "\r\n";
    ss << "Content-Type: " << content_type << "\r\n";
    ss << "Content-Length: " << body.length() << "\r\n";
    ss << "Connection: close\r\n";
    ss << "\r\n";
    ss << body;
    std::string response = ss.str();
    send(sock, response.c_str(), response.length(), 0);
}

void handle_client(socket_t client_socket) {
    // 1. 先接收第一块数据，希望能包含所有头部
    std::vector<char> buffer(BUFFER_SIZE);
    int bytes_received = recv(client_socket, buffer.data(), buffer.size(), 0);
    if (bytes_received <= 0) {
        closesocket(client_socket);
        return;
    }

    // 2. 找到头部和主体的分界线
    std::string full_request(buffer.data(), bytes_received);
    size_t header_end_pos = full_request.find("\r\n\r\n");
    if (header_end_pos == std::string::npos) {
        send_response(client_socket, "400 Bad Request", "text/plain", "Invalid HTTP request headers.");
        closesocket(client_socket);
        return;
    }

    std::string headers_part = full_request.substr(0, header_end_pos);

    // 3. 解析头部
    std::istringstream headers_stream(headers_part);
    std::string method, path;
    headers_stream >> method >> path;
    
    std::map<std::string, std::string> headers;
    std::string line;
    std::getline(headers_stream, line); 
    while(std::getline(headers_stream, line) && line != "\r") {
        size_t colon_pos = line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = line.substr(0, colon_pos);
            std::transform(key.begin(), key.end(), key.begin(), ::tolower);
            std::string value = line.substr(colon_pos + 2);
            if (!value.empty() && value.back() == '\r') value.pop_back();
            headers[key] = value;
        }
    }
    
    // --- 处理 GET 请求 ---
    if (method == "GET" && path == "/") {
        send_response(client_socket, "200 OK", "text/html", htmlPageWithJs);
        closesocket(client_socket);
        return;
    }
    
    // --- 处理 POST 请求 ---
    if (method == "POST" && path == "/upload") {
        // 4. 检查必需的头部
        if (headers.find("content-length") == headers.end() || headers.find("x-file-name") == headers.end()) {
            send_response(client_socket, "400 Bad Request", "text/plain", "Missing Content-Length or X-File-Name header.");
            closesocket(client_socket);
            return;
        }

        size_t content_length = 0;
        try {
            content_length = std::stoul(headers["content-length"]);
        } catch (...) {
            send_response(client_socket, "400 Bad Request", "text/plain", "Invalid Content-Length header.");
            closesocket(client_socket);
            return;
        }

        std::string filename = headers["x-file-name"];
        std::cout << "Receiving file: " << filename << " (" << content_length << " bytes)" << std::endl;

        // 5. 计算已接收的和还需要接收的body大小
        std::string body_part;
        body_part.reserve(content_length); 
        
        body_part.append(full_request.begin() + header_end_pos + 4, full_request.end());
        
        size_t received_body_size = body_part.length();
        
        // 6. 循环接收，直到接收完Content-Length指定的所有字节
        while (received_body_size < content_length) {
            bytes_received = recv(client_socket, buffer.data(), buffer.size(), 0);
            if (bytes_received <= 0) {
                std::cerr << "Client disconnected before sending full file." << std::endl;
                closesocket(client_socket);
                return;
            }
            body_part.append(buffer.data(), bytes_received);
            received_body_size += bytes_received;
        }
        
        // 7. 写入文件 (确保写入正确的大小)
        std::ofstream outfile(filename, std::ios::binary);
        if (!outfile) {
            send_response(client_socket, "500 Internal Server Error", "text/plain", "Could not create file on server.");
        } else {
            outfile.write(body_part.c_str(), content_length); // 使用 content_length 确保不会多写
            outfile.close();

            std::cout << "Successfully saved '" << filename << "'" << std::endl;
            std::string success_msg = "File '" + filename + "' uploaded successfully!";
            send_response(client_socket, "200 OK", "text/plain", success_msg);
        }
    } else {
        send_response(client_socket, "404 Not Found", "text/plain", "Not Found");
    }
    
    closesocket(client_socket);
}


int main() {
#ifdef _WIN32
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);
#endif

    socket_t listen_socket = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // 允许地址重用，方便服务器快速重启
    int opt = 1;
    setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));
    
    if (bind(listen_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
        std::cerr << "Bind failed." << std::endl; closesocket(listen_socket); return 1;
    }

    if (listen(listen_socket, SOMAXCONN) == SOCKET_ERROR) {
        std::cerr << "Listen failed." << std::endl; closesocket(listen_socket); return 1;
    }

    std::cout << "C++ Binary Stream server listening on http://localhost:" << PORT << std::endl;

    while (true) {
        socket_t client_socket = accept(listen_socket, NULL, NULL);
        if (client_socket == INVALID_SOCKET) {
            std::cerr << "Accept failed." << std::endl; 
            continue;
        }
        std::thread(handle_client, client_socket).detach();
    }

    closesocket(listen_socket);
#ifdef _WIN32
    WSACleanup();
#endif
    return 0;
}

```

## 作业：

(1) 将客户端和服务端的代码都自己再写一遍，理解一 下。

(2) 基于 Python，Flaskapi 库实现简单 http 请求（这 个作业不提交）


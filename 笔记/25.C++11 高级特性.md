

# C++11 引入的新特性

## 课程目标
- 深入理解C++11相对于C++98/03带来的革命性变化
- 掌握核心新特性的使用方法和应用场景
- 通过实例分析理解这些特性如何提升代码质量和性能
- 培养现代C++编程思维，为后续学习C++14/17/20打下基础

## 1. 自动类型推导 - `auto`

### 1.1 简介
C++11引入了`auto`关键字，用于自动类型推导。在C++98中，`auto`只是一个存储类型说明符（几乎无人使用），而在C++11中，它被重新定义为类型推导关键字，让编译器根据初始化表达式自动推断变量的类型。

### 1.2 详细语法与示例

```cpp
// 基本类型推导
auto i = 42;          // i是int
auto d = 3.14;        // d是double
auto c = 'a';         // c是char
auto p = &i;          // p是int*
auto str = "Hello";   // str是const char*,

// 引用和const/volatile限定符
const int ci = 10;
auto cai = ci;        // cai是int（const被丢弃）
auto& ccri = ci;      // ccri是const int&（保留const）
auto* pci = &ci;      // pci是const int*（保留const）

// 复杂类型推导
std::vector<int> vec = {1, 2, 3, 4, 5};
auto it = vec.begin();            // it是std::vector<int>::iterator
auto rit = vec.rbegin();          // rit是std::vector<int>::reverse_iterator

// 使用auto简化函数模板返回类型
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}

// C++14中可以直接使用auto推导返回类型
template<typename T, typename U>
auto multiply(T t, U u) {
    return t * u;
}
```

### 1.3 使用场景与优势
1. **简化复杂类型声明**：
   ```cpp
   // 不使用auto
   std::map<std::string, std::vector<int>>::const_iterator it = myMap.begin();
   
   // 使用auto
   auto it = myMap.begin();
   ```

2. **提高代码可维护性**：当类型发生变化时，使用auto的代码无需修改。

3. **与模板和泛型编程完美结合**：
   
   ```cpp
   template<typename T>
   void process(const T& container) {
       for(auto it = container.begin(); it != container.end(); ++it) {
           // 处理元素
       }
   }
   ```
   
4. **与lambda表达式配合使用**：
   
   ```cpp
   auto lambda = [](int x, int y) { return x + y; };
   ```

### 1.4 注意事项

1. **auto必须初始化**：因为auto需要根据初始化表达式推导类型。
   ```cpp
   auto x;  // 错误！缺少初始化表达式
   ```

2. **auto不是动态类型**：类型在编译时确定，不是运行时确定。

3. **auto会丢弃引用和const/volatile限定符**（除非显式指定）：
   
   ```cpp
   int i = 42;
   int& ri = i;
   const int ci = i;
   
   auto a1 = ri;   // a1是int，不是int&
   auto a2 = ci;   // a2是int，不是const int
   
   // 如果想保留引用或const，需要显式指定
   auto& a3 = ri;  // a3是int&
   const auto a4 = ci;  // a4是const int
   ```
   
4. **auto不能用于函数参数（C++11）**：
   
   ```cpp
   void func(auto x) { }  // 错误！auto不能用于函数参数 C++11不可以
   // 应该使用模板
   template<typename T>
   void func(T x) { }
   ```

### 1.5 实际应用示例
```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

int main() {
    // 使用auto简化STL容器遍历
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 传统方式
    for(std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 使用auto
    for(auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 使用auto与范围for循环（后面会讲到）
    for(const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 使用auto处理复杂容器
    std::map<std::string, std::vector<int>> studentScores;
    studentScores["Alice"] = {90, 85, 95};
    studentScores["Bob"] = {80, 75, 85};
    
    // 遍历map
    for(const auto& pair : studentScores) {
        std::cout << pair.first << ": ";
        for(const auto& score : pair.second) {
            std::cout << score << " ";
        }
        std::cout << std::endl;
    }
    
    // 使用auto与STL算法
    auto it = std::find_if(numbers.begin(), numbers.end(), 
                          [](int n) { return n > 3; });
    if(it != numbers.end()) {
        std::cout << "Found number greater than 3: " << *it << std::endl;
    }
    
    return 0;
}
```

## 2. Lambda 表达式

### 2.1 简介
Lambda表达式是C++11引入的一个重要特性，它允许在需要的地方创建匿名函数对象。Lambda表达式提供了一种简洁、灵活的方式来定义函数对象，特别适合用于短小的函数逻辑，尤其是作为算法的参数。

### 2.2 Lambda语法详解
Lambda表达式的基本语法如下：
```cpp
[capture](parameters) -> return_type { body }
```

- **捕获子句(capture)**：指定如何从外部作用域捕获变量。
- **参数列表(parameters)**：类似于普通函数的参数列表。
- **返回类型(return_type)**：使用尾随返回类型指定返回类型。如果可以推导，可以省略。
- **函数体(body)**：Lambda表达式的执行代码。

### 2.3 捕获子句详解
捕获子句决定了Lambda表达式如何访问外部作用域的变量：

1. **值捕获**：复制外部变量的值到Lambda内部。
   ```cpp
   int x = 10;
   auto lambda = [x]() { return x * 2; };  // x被复制到lambda内部
   ```

2. **引用捕获**：通过引用访问外部变量。
   ```cpp
   int x = 10;
   auto lambda = [&x]() { x *= 2; };  // x通过引用被捕获
   ```

3. **隐式捕获**：让编译器自动推断捕获方式。
   ```cpp
   int x = 10, y = 20;
   auto lambda1 = [=]() { return x + y; };    // 值捕获所有外部变量
   auto lambda2 = [&]() { x++; y++; };        // 引用捕获所有外部变量
   ```

4. **混合捕获**：指定某些变量的捕获方式，其余使用隐式捕获。
   ```cpp
   int x = 10, y = 20, z = 30;
   auto lambda = [=, &z]() { return x + y + z; };  // x,y值捕获，z引用捕获
   ```

5. **初始化捕获(C++14)**：在捕获时创建新变量。
   
   ```cpp
   int x = 10;
   auto lambda = [y = x + 1]() { return y; };  // y初始化为x+1
   ```

### 2.4 Lambda表达式类型
每个Lambda表达式都有一个唯一的、未命名的类型，相当于一个带有operator()的类。这个类型是编译器生成的，无法直接获取。但是，可以使用`std::function`或`auto`来存储Lambda表达式：

```cpp
#include <functional>

std::function<int(int, int)> add = [](int a, int b) { return a + b; };
auto multiply = [](int a, int b) { return a * b; };
```

### 2.5 实际应用示例

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
#include <map>

class Student {
public:
    Student(const std::string& name, int age, double gpa) 
        : name(name), age(age), gpa(gpa) {}
    
    std::string getName() const { return name; }
    int getAge() const { return age; }
    double getGpa() const { return gpa; }
    
    void print() const {
        std::cout << "Name: " << name << ", Age: " << age << ", GPA: " << gpa << std::endl;
    }

private:
    std::string name;
    int age;
    double gpa;
};

int main() {
    // 示例1：使用Lambda对容器进行排序
    std::vector<Student> students = {
        Student("Alice", 20, 3.8),
        Student("Bob", 21, 3.5),
        Student("Charlie", 19, 3.9),
        Student("David", 22, 3.2)
    };
    
    // 按GPA降序排序
    std::sort(students.begin(), students.end(), 
              [](const Student& a, const Student& b) {
                  return a.getGpa() > b.getGpa();
              });
    
    std::cout << "Students sorted by GPA (descending):" << std::endl;
    for(const auto& student : students) {
        student.print();
    }
    
    // 示例2：使用Lambda计算统计信息
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 计算偶数的数量
    int evenCount = std::count_if(numbers.begin(), numbers.end(), 
                                 [](int n) { return n % 2 == 0; });
    std::cout << "Count of even numbers: " << evenCount << std::endl;
    
    // 计算所有奇数的和
    int oddSum = 0;
    std::for_each(numbers.begin(), numbers.end(), 
                 [&oddSum](int n) { if(n % 2 != 0) oddSum += n; });
    std::cout << "Sum of odd numbers: " << oddSum << std::endl;
    
    // 示例3：使用Lambda和std::transform
    std::vector<std::string> names = {"Alice", "Bob", "Charlie"};
    std::vector<int> nameLengths;
    
    // 将names中的每个字符串转换为其长度
    std::transform(names.begin(), names.end(), std::back_inserter(nameLengths),
                  [](const std::string& s) { return s.length(); });
    
    std::cout << "Name lengths: ";
    for(const auto& len : nameLengths) {
        std::cout << len << " ";
    }
    std::cout << std::endl;
    
    // 示例4：使用Lambda和std::remove_if
    // 移除所有小于5的数字
    numbers.erase(std::remove_if(numbers.begin(), numbers.end(), 
                                [](int n) { return n < 5; }), 
                 numbers.end());
    
    std::cout << "Numbers after removing those less than 5: ";
    for(const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 示例5：使用Lambda和std::accumulate
    // 连接所有字符串
    std::string concatenated = std::accumulate(names.begin(), names.end(), std::string(),
                                               [](const std::string& a, const std::string& b) {
                                                   return a + " " + b;
                                               });
    std::cout << "Concatenated names: " << concatenated << std::endl;
    
    // 示例6：使用Lambda创建自定义比较函数
    std::map<std::string, int, std::function<bool(const std::string&, const std::string&)>> 
        customMap([](const std::string& a, const std::string& b) {
            return a.length() < b.length();  // 按字符串长度排序
        });
    
    customMap["Alice"] = 20;
    customMap["Bob"] = 25;
    customMap["Charlie"] = 30;
    
    std::cout << "Map sorted by key length:" << std::endl;
    for(const auto& pair : customMap) {
        std::cout << pair.first << " -> " << pair.second << std::endl;
    }
    
    return 0;
}
```

### 2.6 Lambda表达式的优势
1. **代码简洁**：避免了为简单操作定义单独的函数或函数对象。
2. **就地定义**：在需要使用的地方直接定义，提高了代码的可读性。
3. **捕获外部变量**：可以方便地访问外部作用域的变量，使代码更加灵活。
4. **与STL算法完美结合**：作为STL算法的参数，提供了强大的自定义能力。

### 2.7 注意事项

1. **引用捕获的生命周期问题**：如果Lambda表达式引用捕获了局部变量，而Lambda的生命周期超过了该变量，会导致未定义行为。
   
   ```cpp
   std::function<int()> getLambda() {
       int x = 10;
       return [&x]() { return x; };  // 危险！x在getLambda返回时被销毁
   }
   ```
   
2. **值捕获的常量性**：默认情况下，值捕获的变量在Lambda内部是const的，如果需要修改，需要使用mutable关键字。
   
   ```cpp
   int x = 10;
   auto lambda = [x]() mutable { x++; return x; };  // OK，x可以修改
   ```
   
3. **Lambda表达式的性能**：Lambda表达式通常会被编译器优化为与普通函数对象相同的代码，性能开销很小。但在性能关键的场景，仍需注意捕获方式带来的影响。

## 3. 右值引用与移动行为

### 3.1 简介
C++11引入了右值引用(`&&`)和移动语义，这是C++11最重要的特性之一。右值引用允许我们区分左值和右值，从而实现移动语义，避免不必要的拷贝操作，显著提高程序性能，特别是对于管理资源的类。

### 3.2 左值与右值的概念
在C++中，表达式可以分为左值(lvalue)和右值(rvalue)：

- **左值**：表示一个可以取地址的对象，通常出现在赋值运算符的左边。
- **右值**：表示一个临时的值，不能取地址，通常出现在赋值运算符的右边。

```cpp
int x = 5; 
int y = x; 

int foo() { return 42; }
int z = foo();  // foo()返回的是右值
```

### 3.3 右值引用语法
右值引用使用`&&`声明，与左值引用(`&`)相对应：

```cpp
int x = 5;
int& lref = x;       // 左值引用
int&& rref = 5;      // 右值引用
int&& rref2 = x;     // 错误！不能将左值绑定到右值引用
int&& rref3 = std::move(x);  // OK，通过std::move将左值转换为右值引用
```

### 3.4 移动行为

移动语义允许资源（如内存、文件句柄等）从一个对象"移动"到另一个对象，而不是复制。这对于管理大量资源的类来说，可以显著提高性能。

```cpp
#include <iostream>
#include <cstring>
#include <utility>  // for std::move

class DynamicArray {
private:
    int* m_data;
    size_t m_size;
    
public:
    // 构造函数
    explicit DynamicArray(size_t size = 0) 
        : m_size(size), m_data(new int[size]) {
        std::cout << "Constructed array of size " << m_size << std::endl;
    }
    
    // 析构函数
    ~DynamicArray() {
        delete[] m_data;
        std::cout << "Destroyed array of size " << m_size << std::endl;
    }
    
    // 拷贝构造函数
    DynamicArray(const DynamicArray& other) 
        : m_size(other.m_size), m_data(new int[other.m_size]) {
        std::cout << "Copy constructed array of size " << m_size << std::endl;
        std::copy(other.m_data, other.m_data + m_size, m_data);
    }
    
    // 拷贝赋值运算符
    DynamicArray& operator=(const DynamicArray& other) {
        if (this != &other) {
            delete[] m_data;
            m_size = other.m_size;
            m_data = new int[m_size];
            std::copy(other.m_data, other.m_data + m_size, m_data);
            std::cout << "Copy assigned array of size " << m_size << std::endl;
        }
        return *this;
    }
    
    // 移动构造函数
    DynamicArray(DynamicArray&& other) noexcept 
        : m_data(nullptr), m_size(0) {
        std::cout << "Move constructed array of size " << other.m_size << std::endl;
        // "窃取"other的资源
        m_data = other.m_data;
        m_size = other.m_size;
        // 将other置于有效但未指定的状态
        other.m_data = nullptr;
        other.m_size = 0;
    }
    
    // 移动赋值运算符
    DynamicArray& operator=(DynamicArray&& other) noexcept {
        if (this != &other) {
            delete[] m_data;  // 释放当前资源
            
            std::cout << "Move assigned array of size " << other.m_size << std::endl;
            // "窃取"other的资源
            m_data = other.m_data;
            m_size = other.m_size;
            // 将other置于有效但未指定的状态
            other.m_data = nullptr;
            other.m_size = 0;
        }
        return *this;
    }
    
    size_t size() const { return m_size; }
    
    int& operator[](size_t index) {
        return m_data[index];
    }
    
    const int& operator[](size_t index) const {
        return m_data[index];
    }
};

// 创建并返回一个大数组的函数
DynamicArray createLargeArray(size_t size) {
    DynamicArray arr(size);
    // 填充数组...
    for (size_t i = 0; i < size; ++i) {
        arr[i] = static_cast<int>(i);
    }
    return arr;  // 这里会使用移动语义而不是拷贝
}

int main() {
    // 创建一个大数组
    DynamicArray arr1 = createLargeArray(1000000);
    std::cout << "arr1 size: " << arr1.size() << std::endl;
    
    // 使用移动构造函数
    DynamicArray arr2 = std::move(arr1);
    std::cout << "arr2 size: " << arr2.size() << std::endl;
    std::cout << "arr1 size: " << arr1.size() << std::endl;
    
    // 使用移动赋值运算符
    DynamicArray arr3;
    arr3 = std::move(arr2);
    std::cout << "arr3 size: " << arr3.size() << std::endl;
    std::cout << "arr2 size: " << arr2.size() << std::endl;
    
    return 0;
}
```

### 3.7 移动的优势

1. **性能提升**：避免不必要的拷贝，特别是对于大型对象或资源密集型对象。
2. **资源管理**：更高效地转移资源所有权，减少资源占用。
3. **异常安全**：移动操作通常被标记为noexcept，提供更强的异常安全保证。
4. **标准库优化**：STL容器和算法广泛使用移动语义，提高整体性能。

### 3.8 应用场景
1. **实现资源管理类**：如动态数组、文件句柄、网络连接等。
2. **优化STL容器操作**：如vector的resize、insert等操作。
3. **实现工厂模式**：返回大型对象时避免拷贝。

## 4. 标准库的改进

### 4.1 智能指针
C++11引入了新的智能指针，替代了C++98中的`std::auto_ptr`，提供了更安全、更灵活的内存管理方式。

#### 4.1.1 std::unique_ptr

`std::unique_ptr`是一种独占所有权的智能指针，它确保在任何时刻只有一个指针指向对象。当`unique_ptr`被销毁时，它所指向的对象也会被自动删除。

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Resource {
public:
    Resource() { std::cout << "Resource acquired" << std::endl; }
    ~Resource() { std::cout << "Resource destroyed" << std::endl; }
    void doSomething() { std::cout << "Doing something" << std::endl; }
};

void processResource(std::unique_ptr<Resource> res) {
    res->doSomething();
    // res在这里自动销毁，Resource也被自动释放
}

int main() {
    // 创建unique_ptr
    std::unique_ptr<Resource> res1(new Resource());
    res1->doSomething();
    
    // 使用std::make_unique创建unique_ptr (C++14)
    auto res2 = std::make_unique<Resource>();
    res2->doSomething();
    
    // unique_ptr不能复制，只能移动
    // std::unique_ptr<Resource> res3 = res1;  // 错误！不能复制
    std::unique_ptr<Resource> res4 = std::move(res1);  // OK，移动所有权
    // res1现在为空
    
    // 可以将unique_ptr传递给函数，通过移动语义转移所有权
    processResource(std::move(res4));
    // res4现在为空
    
    // unique_ptr可以用于管理数组
    std::unique_ptr<int[]> arr(new int[5]{1, 2, 3, 4, 5});
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    
    // unique_ptr在容器中的使用
    std::vector<std::unique_ptr<Resource>> resources;
    resources.push_back(std::make_unique<Resource>());
    resources.push_back(std::make_unique<Resource>());
    
    // 当vector被销毁时，所有Resource也会被自动释放
    
    return 0;
}
```

#### 4.1.2 std::shared_ptr
`std::shared_ptr`是一种共享所有权的智能指针，多个`shared_ptr`可以指向同一个对象。它使用引用计数来跟踪有多少个`shared_ptr`指向对象，当最后一个`shared_ptr`被销毁时，对象才会被删除。

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <thread>
#include <chrono>

class Resource {
public:
    Resource(int id) : id_(id) { 
        std::cout << "Resource " << id_ << " acquired" << std::endl; 
    }
    ~Resource() { 
        std::cout << "Resource " << id_ << " destroyed" << std::endl; 
    }
    int getId() const { return id_; }
    void doSomething() { 
        std::cout << "Resource " << id_ << " is doing something" << std::endl; 
    }

private:
    int id_;
};

void useResource(std::shared_ptr<Resource> res, int duration) {
    std::cout << "Thread using resource " << res->getId() << " for " << duration << " seconds" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(duration));
    res->doSomething();
    std::cout << "Thread finished using resource " << res->getId() << std::endl;
}

int main() {
    // 创建shared_ptr
    std::shared_ptr<Resource> res1(new Resource(1));
    std::cout << "res1 use count: " << res1.use_count() << std::endl;
    
    // 使用std::make_shared创建shared_ptr（更高效）
    auto res2 = std::make_shared<Resource>(2);
    std::cout << "res2 use count: " << res2.use_count() << std::endl;
    
    // 复制shared_ptr，增加引用计数
    std::shared_ptr<Resource> res3 = res2;
    std::cout << "res2 use count after copy: " << res2.use_count() << std::endl;
    std::cout << "res3 use count: " << res3.use_count() << std::endl;
    
    // shared_ptr在容器中的使用
    std::vector<std::shared_ptr<Resource>> resources;
    resources.push_back(std::make_shared<Resource>(3));
    resources.push_back(std::make_shared<Resource>(4));
    resources.push_back(res2);  // res2的引用计数增加
    
    std::cout << "res2 use count after adding to vector: " << res2.use_count() << std::endl;
    
    // 多线程环境下使用shared_ptr
    std::shared_ptr<Resource> sharedRes = std::make_shared<Resource>(5);
    std::cout << "sharedRes use count: " << sharedRes.use_count() << std::endl;
    
    std::thread t1(useResource, sharedRes, 2);
    std::thread t2(useResource, sharedRes, 1);
    
    std::cout << "sharedRes use count after starting threads: " << sharedRes.use_count() << std::endl;
    
    t1.join();
    t2.join();
    
    std::cout << "sharedRes use count after threads finished: " << sharedRes.use_count() << std::endl;
    
    // 使用weak_ptr解决循环引用问题
    std::cout << "\nDemonstrating weak_ptr to avoid circular references:" << std::endl;
    
    struct Node {
        std::string name;
        std::shared_ptr<Node> next;
        std::weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
        
        Node(const std::string& n) : name(n) {
            std::cout << "Node " << name << " created" << std::endl;
        }
        
        ~Node() {
            std::cout << "Node " << name << " destroyed" << std::endl;
        }
    };
    
    std::shared_ptr<Node> node1 = std::make_shared<Node>("Node1");
    std::shared_ptr<Node> node2 = std::make_shared<Node>("Node2");
    
    node1->next = node2;
    node2->prev = node1;  // 使用weak_ptr，不会增加引用计数
    
    std::cout << "node1 use count: " << node1.use_count() << std::endl;
    std::cout << "node2 use count: " << node2.use_count() << std::endl;
    
    // 访问weak_ptr指向的对象
    if (auto locked = node2->prev.lock()) {
        std::cout << "Previous node of node2 is: " << locked->name << std::endl;
    } else {
        std::cout << "Previous node of node2 is expired" << std::endl;
    }
    
    return 0;
}
```

#### 4.1.3 std::weak_ptr

`std::weak_ptr`是一种不控制对象生命周期的智能指针，它指向一个由`shared_ptr`管理的对象，但不增加引用计数。`weak_ptr`主要用于解决`shared_ptr`的循环引用问题。

### 4.2 正则表达式库
C++11引入了正则表达式库，提供了强大的文本模式匹配功能。

```cpp
#include <iostream>
#include <regex>
#include <string>
#include <vector>

int main() {
    // 基本正则表达式匹配
    std::string text = "The quick brown fox jumps over the lazy dog.";
    std::regex pattern("\\b\\w{5}\\b");  // 匹配5个字母的单词
    
    // 使用std::regex_search查找匹配
    std::smatch match;
    if (std::regex_search(text, match, pattern)) {
        std::cout << "Found match: " << match.str() << std::endl;
    }
    
    // 使用std::sregex_iterator查找所有匹配
    std::vector<std::string> matches;
    std::sregex_iterator it(text.begin(), text.end(), pattern);
    std::sregex_iterator end;
    
    while (it != end) {
        matches.push_back(it->str());
        ++it;
    }
    
    std::cout << "All 5-letter words: ";
    for (const auto& m : matches) {
        std::cout << m << " ";
    }
    std::cout << std::endl;
    
    // 使用std::regex_replace进行替换
    std::string result = std::regex_replace(text, std::regex("\\bfox\\b"), "cat");
    std::cout << "After replacement: " << result << std::endl;
    
    // 验证电子邮件格式
    std::vector<std::string> emails = {
        "user@example.com",
        "firstname.lastname@sub.domain.com",
        "invalid.email",
        "another@invalid",
        "valid@example.org"
    };
    
    std::regex email_pattern(R"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})");
    
    std::cout << "\nValidating email addresses:" << std::endl;
    for (const auto& email : emails) {
        if (std::regex_match(email, email_pattern)) {
            std::cout << email << " is valid" << std::endl;
        } else {
            std::cout << email << " is invalid" << std::endl;
        }
    }
    
    // 提取HTML标签内容
    std::string html = "<html><head><title>Example</title></head><body><p>Hello, world!</p></body></html>";
    std::regex tag_pattern("<([^>]+)>([^<]+)</\\1>");
    
    std::cout << "\nExtracting HTML tag contents:" << std::endl;
    std::sregex_iterator html_it(html.begin(), html.end(), tag_pattern);
    std::sregex_iterator html_end;
    
    while (html_it != html_end) {
        std::cout << "Tag: " << (*html_it)[1] << ", Content: " << (*html_it)[2] << std::endl;
        ++html_it;
    }
    
    return 0;
}
```

### 4.3 时间库(Chrono)

C++11引入了`<chrono>`库，提供了处理时间和持续时间的类型和函数。

```cpp
#include <iostream>
#include <chrono>
#include <thread>
#include <ratio>

int main() {
    // 使用steady_clock测量时间间隔
    std::cout << "Measuring time with steady_clock:" << std::endl;
    
    auto start = std::chrono::steady_clock::now();
    
    // 执行一些操作
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Operation took " << duration.count() << " milliseconds" << std::endl;
    
    // 使用system_clock获取当前时间
    auto now = std::chrono::system_clock::now();
    std::time_t now_time = std::chrono::system_clock::to_time_t(now);
    
    std::cout << "\nCurrent time: " << std::ctime(&now_time);
    
    // 使用high_resolution_clock进行高精度计时
    std::cout << "\nHigh resolution timing:" << std::endl;
    
    auto hr_start = std::chrono::high_resolution_clock::now();
    
    // 执行一些操作
    long long sum = 0;
    for (int i = 0; i < 1000000; ++i) {
        sum += i;
    }
    
    auto hr_end = std::chrono::high_resolution_clock::now();
    auto hr_duration = std::chrono::duration_cast<std::chrono::microseconds>(hr_end - hr_start);
    
    std::cout << "Sum: " << sum << std::endl;
    std::cout << "Calculation took " << hr_duration.count() << " microseconds" << std::endl;
    
    // 使用自定义时间单位
    std::cout << "\nUsing custom duration units:" << std::endl;
    
    // 定义一个基于毫秒的duration
    using milliseconds = std::chrono::duration<double, std::milli>;
    
    // 定义一个基于帧率的duration（60 FPS）
    using frames = std::chrono::duration<double, std::ratio<1, 60>>;
    
    auto frame_start = std::chrono::steady_clock::now();
    std::this_thread::sleep_for(std::chrono::milliseconds(16));  // 大约一帧的时间
    auto frame_end = std::chrono::steady_clock::now();
    
    frames frame_duration = frame_end - frame_start;
    milliseconds ms_duration = frame_end - frame_start;
    
    std::cout << "Frame duration: " << frame_duration.count() << " frames (60 FPS)" << std::endl;
    std::cout << "Frame duration: " << ms_duration.count() << " milliseconds" << std::endl;
    
    // 时间点的算术运算
    std::cout << "\nTime point arithmetic:" << std::endl;
    
    auto current_time = std::chrono::system_clock::now();
    auto future_time = current_time + std::chrono::hours(24);
    
    std::time_t current_c_time = std::chrono::system_clock::to_time_t(current_time);
    std::time_t future_c_time = std::chrono::system_clock::to_time_t(future_time);
    
    std::cout << "Current time: " << std::ctime(&current_c_time);
    std::cout << "Future time (24 hours later): " << std::ctime(&future_c_time);
    
    return 0;
}
```

### 4.4 其他STL改进

C++11还对STL容器和算法进行了许多改进：

```cpp
#include <iostream>
#include <vector>
#include <array>
#include <forward_list>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <algorithm>
#include <numeric>

int main() {
    // 使用std::array替代C风格数组
    std::cout << "Using std::array:" << std::endl;
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    
    for (const auto& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // 使用std::forward_list（单向链表）
    std::cout << "\nUsing std::forward_list:" << std::endl;
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    
    // 在forward_list中插入元素
    flist.push_front(0);
    auto it = flist.begin();
    std::advance(it, 3);
    flist.insert_after(it, 99);
    
    for (const auto& elem : flist) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // 使用无序关联容器
    std::cout << "\nUsing unordered containers:" << std::endl;
    
    std::unordered_map<std::string, int> uomap = {
        {"Alice", 25},
        {"Bob", 30},
        {"Charlie", 35}
    };
    
    for (const auto& pair : uomap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    
    std::unordered_set<int> uset = {1, 2, 3, 4, 5, 5, 4, 3, 2, 1};
    
    std::cout << "Unique elements: ";
    for (const auto& elem : uset) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // 使用std::tuple
    std::cout << "\nUsing std::tuple:" << std::endl;
    
    std::tuple<int, std::string, double> person(25, "Alice", 65.5);
    
    std::cout << "Age: " << std::get<0>(person) << std::endl;
    std::cout << "Name: " << std::get<1>(person) << std::endl;
    std::cout << "Weight: " << std::get<2>(person) << std::endl;
    
    // 使用std::tie解包tuple
    int age;
    std::string name;
    double weight;
    std::tie(age, name, weight) = person;
    
    std::cout << "Unpacked: " << name << ", " << age << " years, " << weight << " kg" << std::endl;
    
    // 使用新的STL算法
    std::cout << "\nUsing new STL algorithms:" << std::endl;
    
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 使用std::all_of检查是否所有元素都满足条件
    bool all_even = std::all_of(numbers.begin(), numbers.end(), 
                               [](int n) { return n % 2 == 0; });
    std::cout << "All numbers are even? " << (all_even ? "Yes" : "No") << std::endl;
    
    // 使用std::any_of检查是否有任何元素满足条件
    bool any_even = std::any_of(numbers.begin(), numbers.end(), 
                               [](int n) { return n % 2 == 0; });
    std::cout << "Any number is even? " << (any_even ? "Yes" : "No") << std::endl;
    
    // 使用std::none_of检查是否没有元素满足条件
    bool none_greater_than_10 = std::none_of(numbers.begin(), numbers.end(), 
                                           [](int n) { return n > 10; });
    std::cout << "No number is greater than 10? " << (none_greater_than_10 ? "Yes" : "No") << std::endl;
    
    // 使用std::minmax_element同时查找最小和最大元素
    auto minmax = std::minmax_element(numbers.begin(), numbers.end());
    std::cout << "Min: " << *minmax.first << ", Max: " << *minmax.second << std::endl;
    
    // 使用std::is_sorted检查是否已排序
    bool is_sorted = std::is_sorted(numbers.begin(), numbers.end());
    std::cout << "Numbers are sorted? " << (is_sorted ? "Yes" : "No") << std::endl;
    
    // 使用std::iota填充序列
    std::vector<int> sequence(10);
    std::iota(sequence.begin(), sequence.end(), 1);
    
    std::cout << "Sequence filled with iota: ";
    for (const auto& num : sequence) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 5. 多线程支持

### 5.1 简介
C++11首次在标准库中引入了对多线程的原生支持，包括线程管理、互斥量、条件变量和原子操作等。这使得C++程序员能够编写可移植的多线程程序，而无需依赖平台特定的API。

### 5.2 线程管理
`std::thread`类提供了对线程的基本支持：

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
#include <functional>

void hello() {
    std::cout << "Hello, concurrent world!" << std::endl;
}

void printMessage(const std::string& message, int times) {
    for (int i = 0; i < times; ++i) {
        std::cout << message << " (" << i + 1 << "/" << times << ")" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {
    // 创建并启动一个线程
    std::cout << "Starting a thread..." << std::endl;
    std::thread t(hello);
    
    // 等待线程完成
    t.join();
    std::cout << "Thread finished." << std::endl;
    
    // 创建带参数的线程
    std::cout << "\nStarting a thread with arguments..." << std::endl;
    std::thread t2(printMessage, "Hello from thread", 3);
    
    // 分离线程（让它独立运行）
    t2.detach();
    std::cout << "Thread detached." << std::endl;
    
    // 等待一段时间，以便分离的线程有机会执行
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    // 使用lambda表达式创建线程
    std::cout << "\nStarting a thread with lambda..." << std::endl;
    std::thread t3([]() {
        for (int i = 0; i < 5; ++i) {
            std::cout << "Lambda thread: " << i << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    });
    
    t3.join();
    std::cout << "Lambda thread finished." << std::endl;
    
    // 使用成员函数创建线程
    std::cout << "\nStarting a thread with member function..." << std::endl;
    
    class Worker {
    public:
        void doWork(int id) {
            for (int i = 0; i < 3; ++i) {
                std::cout << "Worker " << id << ": Working... (" << i + 1 << "/3)" << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        }
    };
    
    Worker worker;
    std::thread t4(&Worker::doWork, &worker, 1);
    t4.join();
    std::cout << "Worker thread finished." << std::endl;
    
    // 线程ID
    std::cout << "\nThread IDs:" << std::endl;
    std::cout << "Main thread ID: " << std::this_thread::get_id() << std::endl;
    
    std::thread t5([]() {
        std::cout << "New thread ID: " << std::this_thread::get_id() << std::endl;
    });
    t5.join();
    
    return 0;
}
```

## 6. 其他重要特性

### 6.1 统一初始化
C++11引入了使用大括号`{}`进行统一初始化的方式，可以用于任何类型的对象：

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <string>

class Point {
public:
    Point(int x, int y) : x_(x), y_(y) {}
    
    void print() const {
        std::cout << "Point(" << x_ << ", " << y_ << ")" << std::endl;
    }

private:
    int x_, y_;
};

int main() {
    // 基本类型初始化
    int i{5};
    double d{3.14};
    char c{'A'};
    
    std::cout << "i = " << i << ", d = " << d << ", c = " << c << std::endl;
    
    // 数组初始化
    int arr[]{1, 2, 3, 4, 5};
    std::cout << "Array: ";
    for (const auto& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // 容器初始化
    std::vector<int> vec{1, 2, 3, 4, 5};
    std::map<std::string, int> m{{"Alice", 25}, {"Bob", 30}};
    
    std::cout << "Vector: ";
    for (const auto& elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    std::cout << "Map:" << std::endl;
    for (const auto& pair : m) {
        std::cout << "  " << pair.first << ": " << pair.second << std::endl;
    }
    
    // 自定义类型初始化
    Point p{10, 20};
    p.print();
    
    // 动态分配的数组初始化
    int* dynamicArr = new int[5]{1, 2, 3, 4, 5};
    std::cout << "Dynamic array: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << dynamicArr[i] << " ";
    }
    std::cout << std::endl;
    delete[] dynamicArr;
    
    // 防止窄化转换
    // int x{3.14};  // 错误！窄化转换不允许
    int y = 3.14;   // 警告，但允许
    
    std::cout << "y = " << y << std::endl;
    
    return 0;
}
```

### 6.2 nullptr

`nullptr`是C++11引入的关键字，用于表示空指针，替代了C++98中的`NULL`宏：

```cpp
#include <iostream>

void foo(int* ptr) {
    if (ptr) {
        std::cout << "foo(int*): ptr is not null" << std::endl;
    } else {
        std::cout << "foo(int*): ptr is null" << std::endl;
    }
}

void foo(int i) {
    std::cout << "foo(int): i = " << i << std::endl;
}

int main() {
    int* ptr1 = nullptr;
    int* ptr2 = NULL;
    int* ptr3 = 0;
    
    foo(ptr1);  // 调用foo(int*)
    foo(nullptr);  // 调用foo(int*)
    // foo(NULL);  // 在某些实现中可能调用foo(int)，导致歧义
    
    // nullptr的类型是std::nullptr_t
    decltype(nullptr) null = nullptr;
    
    // nullptr可以转换为任何指针类型
    int* iptr = nullptr;
    char* cptr = nullptr;
    void* vptr = nullptr;
    
    std::cout << "All pointers are null" << std::endl;
    
    return 0;
}
```

### 6.3 强类型枚举
C++11引入了强类型枚举（enum class），解决了传统枚举的一些问题：

```cpp
#include <iostream>

// 传统枚举
enum Color {
    RED = 0,
    GREEN = 1,
    BLUE = 2
};

// 强类型枚举
enum class Direction {
    NORTH,
    SOUTH,
    EAST,
    WEST
};

// 可以指定底层类型
enum class Status : unsigned int {
    OK = 0,
    ERROR = 1,
    PENDING = 2
};

int main() {
    // 传统枚举的问题
    Color c = RED;
    int i = c;  // 隐式转换为int
    std::cout << "Color as int: " << i << std::endl;
    
    // 不同枚举类型的比较
    if (RED == 0) {  // 允许
        std::cout << "RED equals 0" << std::endl;
    }
    
    // 强类型枚举的使用
    Direction d = Direction::NORTH;
    
    // 以下代码会导致编译错误
    // int j = d;  // 错误！不能隐式转换为int
    // if (d == 0) {}  // 错误！不能与整数比较
    
    // 必须显式转换
    int k = static_cast<int>(d);
    std::cout << "Direction as int: " << k << std::endl;
    
    // 不同强类型枚举之间不能比较
    // if (d == Direction::NORTH) {}  // OK，相同类型
    // if (d == Status::OK) {}  // 错误！不同类型
    
    // 强类型枚举可以指定底层类型
    Status s = Status::OK;
    unsigned int u = static_cast<unsigned int>(s);
    std::cout << "Status as unsigned int: " << u << std::endl;
    
    return 0;
}
```

### 6.4 constexpr
`constexpr`关键字允许在编译时计算表达式和函数：

```cpp
#include <iostream>
#include <array>

// constexpr变量
constexpr int MAX_SIZE = 100;

// constexpr函数
constexpr int square(int x) {
    return x * x;
}

// 递归constexpr函数
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

// constexpr类方法
class Circle {
public:
    constexpr Circle(double radius) : radius_(radius) {}
    
    constexpr double area() const {
        return 3.141592653589793 * radius_ * radius_;
    }
    
    constexpr double circumference() const {
        return 2 * 3.141592653589793 * radius_;
    }

private:
    double radius_;
};

int main() {
    // 编译时计算
    constexpr int s = square(5);
    std::cout << "Square of 5: " << s << std::endl;
    
    // 编译时计算阶乘
    constexpr int fact5 = factorial(5);
    std::cout << "Factorial of 5: " << fact5 << std::endl;
    
    // 使用constexpr变量定义数组大小
    std::array<int, MAX_SIZE> arr;
    std::cout << "Array size: " << arr.size() << std::endl;
    
    // constexpr对象和方法
    constexpr Circle c(2.0);
    constexpr double area = c.area();
    constexpr double circumference = c.circumference();
    
    std::cout << "Circle with radius 2.0:" << std::endl;
    std::cout << "  Area: " << area << std::endl;
    std::cout << "  Circumference: " << circumference << std::endl;
    
    // 运行时计算
    int x;
    std::cout << "Enter a number: ";
    std::cin >> x;
    
    // constexpr函数也可以在运行时使用
    int result = square(x);
    std::cout << "Square of " << x << ": " << result << std::endl;
    
    return 0;
}
```

### 6.5 Range-based for loop
基于范围的for循环简化了容器和数组的遍历：

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <array>

int main() {
    // 使用基于范围的for循环遍历数组
    int arr[] = {1, 2, 3, 4, 5};
    std::cout << "Array elements: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // 使用引用修改元素
    std::cout << "Doubling array elements: ";
    for (int& elem : arr) {
        elem *= 2;
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // 使用const引用避免拷贝
    std::cout << "Array elements (const ref): ";
    for (const int& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // 遍历vector
    std::vector<std::string> vec = {"apple", "banana", "cherry"};
    std::cout << "Vector elements: ";
    for (const auto& fruit : vec) {
        std::cout << fruit << " ";
    }
    std::cout << std::endl;
    
    // 遍历map
    std::map<std::string, int> scores = {{"Alice", 90}, {"Bob", 85}, {"Charlie", 95}};
    std::cout << "Map elements:" << std::endl;
    for (const auto& pair : scores) {
        std::cout << "  " << pair.first << ": " << pair.second << std::endl;
    }
    
    // 遍历std::array
    std::array<double, 3> temperatures = {23.5, 24.1, 22.8};
    std::cout << "Temperatures: ";
    for (const auto& temp : temperatures) {
        std::cout << temp << "°C ";
    }
    std::cout << std::endl;
    
    // 使用结构化绑定(C++17)简化map遍历
    // 注意：这里需要C++17支持，如果编译器不支持，可以使用传统方式
    std::cout << "Map elements (structured binding):" << std::endl;
    for (const auto& [name, score] : scores) {
        std::cout << "  " << name << ": " << score << std::endl;
    }
    
    return 0;
}
```

### 6.6 类型别名与别名模板
C++11提供了更清晰的方式来定义类型别名：

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <string>

// 使用using定义类型别名
using Integer = int;
using StringVector = std::vector<std::string>;
using StringIntMap = std::map<std::string, int>;

// 定义函数指针类型别名
using CompareFunc = bool(*)(const int&, const int&);

// 定义别名模板
template<typename T>
using Vec = std::vector<T>;

template<typename K, typename V>
using HashMap = std::map<K, V>;

// 复杂的模板别名
template<typename T>
using Matrix = std::vector<std::vector<T>>;

bool compareInts(const int& a, const int& b) {
    return a < b;
}

int main() {
    // 使用类型别名
    Integer x = 42;
    std::cout << "x = " << x << std::endl;
    
    StringVector names = {"Alice", "Bob", "Charlie"};
    std::cout << "Names: ";
    for (const auto& name : names) {
        std::cout << name << " ";
    }
    std::cout << std::endl;
    
    StringIntMap ages = {{"Alice", 25}, {"Bob", 30}, {"Charlie", 35}};
    std::cout << "Ages:" << std::endl;
    for (const auto& pair : ages) {
        std::cout << "  " << pair.first << ": " << pair.second << std::endl;
    }
    
    // 使用函数指针类型别名
    CompareFunc cmp = compareInts;
    int a = 5, b = 10;
    std::cout << a << " < " << b << "? " << (cmp(a, b) ? "Yes" : "No") << std::endl;
    
    // 使用别名模板
    Vec<double> doubles = {1.1, 2.2, 3.3};
    std::cout << "Doubles: ";
    for (const auto& d : doubles) {
        std::cout << d << " ";
    }
    std::cout << std::endl;
    
    HashMap<std::string, std::string> capitals = {
        {"France", "Paris"},
        {"Germany", "Berlin"},
        {"Italy", "Rome"}
    };
    std::cout << "Capitals:" << std::endl;
    for (const auto& pair : capitals) {
        std::cout << "  " << pair.first << ": " << pair.second << std::endl;
    }
    
    // 使用矩阵别名模板
    Matrix<int> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    std::cout << "Matrix:" << std::endl;
    for (const auto& row : matrix) {
        for (const auto& elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

## 作业

### 练习：实现Lambda函数排序

编写一个程序，使用Lambda表达式对各种容器进行排序和操作。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

class Person {
public:
    Person(const std::string& name, int age) : name_(name), age_(age) {}
    
    const std::string& getName() const { return name_; }
    int getAge() const { return age_; }
    
    void print() const {
        std::cout << name_ << " (" << age_ << " years)" << std::endl;
    }

private:
    std::string name_;
    int age_;
};

int main() {
    // 使用Lambda对整数向量进行排序
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3};
    
    std::cout << "Original numbers: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // TODO:升序排序numbers
    // ....
    
    std::cout << "Sorted in ascending order: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // TODO:降序排序
    // ....
    
    std::cout << "Sorted in descending order: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 使用Lambda对Person对象进行排序
    std::vector<Person> people = {
        Person("Alice", 25),
        Person("Bob", 30),
        Person("Charlie", 20),
        Person("David", 35)
    };
    
    std::cout << "\nOriginal people:" << std::endl;
    for (const auto& person : people) {
        person.print();
    }
    
    // TODO: 按年龄排序
    // ....
    
    std::cout << "\nPeople sorted by age:" << std::endl;
    for (const auto& person : people) {
        person.print();
    }
    
    // TODO: 按姓名排序
    // ....
    
    std::cout << "\nPeople sorted by name:" << std::endl;
    for (const auto& person : people) {
        person.print();
    }
    
    // TODO: 使用Lambda和std::find_if找到年纪大于 30 的人
    // ....
    
    if (it != people.end()) {
        std::cout << "\nFirst person over 30: ";
        it->print();
    }
    
    // 使用Lambda和std::count_if统计年纪大于等于 25 的人数
    // ....
    
    std::cout << "\nNumber of people aged 25 or over: " << count << std::endl;
    
    // 使用Lambda和std::for_each打印所有的信息
    std::cout << "\nPrinting people with Lambda:" << std::endl;
    // ....
    
    return 0;
}
```

**参考实现**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

class Person {
public:
    Person(const std::string& name, int age) : name_(name), age_(age) {}
    
    const std::string& getName() const { return name_; }
    int getAge() const { return age_; }
    
    void print() const {
        std::cout << name_ << " (" << age_ << " years)" << std::endl;
    }

private:
    std::string name_;
    int age_;
};

int main() {
    // 使用Lambda对整数向量进行排序
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3};
    
    std::cout << "Original numbers: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 升序排序
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a < b;
    });
    
    std::cout << "Sorted in ascending order: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 降序排序
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a > b;
    });
    
    std::cout << "Sorted in descending order: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 使用Lambda对Person对象进行排序
    std::vector<Person> people = {
        Person("Alice", 25),
        Person("Bob", 30),
        Person("Charlie", 20),
        Person("David", 35)
    };
    
    std::cout << "\nOriginal people:" << std::endl;
    for (const auto& person : people) {
        person.print();
    }
    
    // 按年龄排序
    std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
        return a.getAge() < b.getAge();
    });
    
    std::cout << "\nPeople sorted by age:" << std::endl;
    for (const auto& person : people) {
        person.print();
    }
    
    // 按姓名排序
    std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
        return a.getName() < b.getName();
    });
    
    std::cout << "\nPeople sorted by name:" << std::endl;
    for (const auto& person : people) {
        person.print();
    }
    
    // 使用Lambda和std::find_if
    auto it = std::find_if(people.begin(), people.end(), [](const Person& p) {
        return p.getAge() > 30;
    });
    
    if (it != people.end()) {
        std::cout << "\nFirst person over 30: ";
        it->print();
    }
    
    // 使用Lambda和std::count_if
    int count = std::count_if(people.begin(), people.end(), [](const Person& p) {
        return p.getAge() >= 25;
    });
    
    std::cout << "\nNumber of people aged 25 or over: " << count << std::endl;
    
    // 使用Lambda和std::for_each
    std::cout << "\nPrinting people with Lambda:" << std::endl;
    std::for_each(people.begin(), people.end(), [](const Person& p) {
        p.print();
    });
    
    return 0;
}
```

## 总结回顾

C++11为现代C++编程带来了革命性的变化，这些特性不仅提高了代码的表达力和安全性，还显著提升了程序的性能。通过本次课程，我们学习了：

1. **自动类型推导(auto)**：简化了复杂类型的声明，提高了代码的可读性和可维护性。

2. **Lambda表达式**：提供了创建匿名函数的便捷方式，使得函数式编程风格在C++中成为可能，特别适合与STL算法配合使用。

3. **右值引用与移动语义**：通过区分左值和右值，实现了资源的"移动"而非"拷贝"，显著提高了程序性能，特别是对于资源密集型对象。

4. **智能指针**：提供了更安全、更灵活的内存管理方式，包括`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`，有效减少了内存泄漏的风险。

5. **多线程支持**：首次在标准库中引入了对多线程的原生支持，包括线程管理、互斥量、条件变量和原子操作等，使得C++程序员能够编写可移植的多线程程序。

6. **其他重要特性**：包括统一初始化、`nullptr`、强类型枚举、`constexpr`、基于范围的for循环等，这些特性共同构成了现代C++编程的基础。

通过这些特性，我们可以写出更安全、更高效、更易维护的C++代码。同时，这些特性也为后续的C++14、C++17和C++20标准奠定了基础。